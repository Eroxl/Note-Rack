/* tslint:disable */
/* eslint-disable */
/**
 * Qdrant API
 * API description for Qdrant vector search engine.  This document describes CRUD and search operations on collections of points (vectors with payload).  Qdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account. ## Examples This examples cover the most basic use-cases - collection creation and basic vector search. ### Create collection First - let\'s create a collection with dot-production metric. ``` curl -X PUT \'http://localhost:6333/collections/test_collection\' \\   -H \'Content-Type: application/json\' \\   --data-raw \'{     \"vectors\": {       \"size\": 4,       \"distance\": \"Dot\"     }   }\'  ``` Expected response: ``` {     \"result\": true,     \"status\": \"ok\",     \"time\": 0.031095451 } ``` We can ensure that collection was created: ``` curl \'http://localhost:6333/collections/test_collection\' ``` Expected response: ``` {   \"result\": {     \"status\": \"green\",     \"vectors_count\": 0,     \"segments_count\": 5,     \"disk_data_size\": 0,     \"ram_data_size\": 0,     \"config\": {       \"params\": {         \"vectors\": {           \"size\": 4,           \"distance\": \"Dot\"         }       },       \"hnsw_config\": {         \"m\": 16,         \"ef_construct\": 100,         \"full_scan_threshold\": 10000       },       \"optimizer_config\": {         \"deleted_threshold\": 0.2,         \"vacuum_min_vector_number\": 1000,         \"max_segment_number\": 5,         \"memmap_threshold\": 50000,         \"indexing_threshold\": 20000,         \"flush_interval_sec\": 1       },       \"wal_config\": {         \"wal_capacity_mb\": 32,         \"wal_segments_ahead\": 0       }     }   },   \"status\": \"ok\",   \"time\": 2.1199e-05 } ```  ### Add points Let\'s now add vectors with some payload: ``` curl -L -X PUT \'http://localhost:6333/collections/test_collection/points?wait=true\' \\ -H \'Content-Type: application/json\' \\ --data-raw \'{   \"points\": [     {\"id\": 1, \"vector\": [0.05, 0.61, 0.76, 0.74], \"payload\": {\"city\": \"Berlin\"}},     {\"id\": 2, \"vector\": [0.19, 0.81, 0.75, 0.11], \"payload\": {\"city\": [\"Berlin\", \"London\"] }},     {\"id\": 3, \"vector\": [0.36, 0.55, 0.47, 0.94], \"payload\": {\"city\": [\"Berlin\", \"Moscow\"] }},     {\"id\": 4, \"vector\": [0.18, 0.01, 0.85, 0.80], \"payload\": {\"city\": [\"London\", \"Moscow\"] }},     {\"id\": 5, \"vector\": [0.24, 0.18, 0.22, 0.44], \"payload\": {\"count\": [0]}},     {\"id\": 6, \"vector\": [0.35, 0.08, 0.11, 0.44]}   ] }\' ``` Expected response: ``` {     \"result\": {         \"operation_id\": 0,         \"status\": \"completed\"     },     \"status\": \"ok\",     \"time\": 0.000206061 } ``` ### Search with filtering Let\'s start with a basic request: ``` curl -L -X POST \'http://localhost:6333/collections/test_collection/points/search\' \\ -H \'Content-Type: application/json\' \\ --data-raw \'{     \"vector\": [0.2,0.1,0.9,0.7],     \"top\": 3 }\' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 1, \"score\": 1.273, \"payload\": null, \"version\": 0 },         { \"id\": 3, \"score\": 1.208, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000055785 } ``` But result is different if we add a filter: ``` curl -L -X POST \'http://localhost:6333/collections/test_collection/points/search\' \\ -H \'Content-Type: application/json\' \\ --data-raw \'{     \"filter\": {         \"should\": [             {                 \"key\": \"city\",                 \"match\": {                     \"value\": \"London\"                 }             }         ]     },     \"vector\": [0.2, 0.1, 0.9, 0.7],     \"top\": 3 }\' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 2, \"score\": 0.871, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000093972 } ``` 
 *
 * The version of the OpenAPI document: master
 * Contact: andrey@vasnetsov.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AbortTransferOperation
 */
export interface AbortTransferOperation {
    /**
     * 
     * @type {MoveShard}
     * @memberof AbortTransferOperation
     */
    'abort_transfer': MoveShard;
}
/**
 * 
 * @export
 * @interface AliasDescription
 */
export interface AliasDescription {
    /**
     * 
     * @type {string}
     * @memberof AliasDescription
     */
    'alias_name': string;
    /**
     * 
     * @type {string}
     * @memberof AliasDescription
     */
    'collection_name': string;
}
/**
 * Group of all the possible operations related to collection aliases
 * @export
 * @interface AliasOperations
 */
export interface AliasOperations {
    /**
     * 
     * @type {CreateAlias}
     * @memberof AliasOperations
     */
    'create_alias': CreateAlias;
    /**
     * 
     * @type {DeleteAlias}
     * @memberof AliasOperations
     */
    'delete_alias': DeleteAlias;
    /**
     * 
     * @type {RenameAlias}
     * @memberof AliasOperations
     */
    'rename_alias': RenameAlias;
}
/**
 * 
 * @export
 * @interface AnyVariants
 */
export interface AnyVariants {
}
/**
 * 
 * @export
 * @interface AppBuildTelemetry
 */
export interface AppBuildTelemetry {
    /**
     * 
     * @type {string}
     * @memberof AppBuildTelemetry
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AppBuildTelemetry
     */
    'version': string;
    /**
     * 
     * @type {AppBuildTelemetryFeatures}
     * @memberof AppBuildTelemetry
     */
    'features'?: AppBuildTelemetryFeatures;
    /**
     * 
     * @type {AppBuildTelemetrySystem}
     * @memberof AppBuildTelemetry
     */
    'system'?: AppBuildTelemetrySystem;
    /**
     * 
     * @type {string}
     * @memberof AppBuildTelemetry
     */
    'startup': string;
}
/**
 * 
 * @export
 * @interface AppBuildTelemetryFeatures
 */
export interface AppBuildTelemetryFeatures {
    /**
     * 
     * @type {boolean}
     * @memberof AppBuildTelemetryFeatures
     */
    'debug': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppBuildTelemetryFeatures
     */
    'web_feature': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppBuildTelemetryFeatures
     */
    'service_debug_feature': boolean;
}
/**
 * 
 * @export
 * @interface AppBuildTelemetrySystem
 */
export interface AppBuildTelemetrySystem {
    /**
     * 
     * @type {string}
     * @memberof AppBuildTelemetrySystem
     */
    'distribution'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AppBuildTelemetrySystem
     */
    'distribution_version'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AppBuildTelemetrySystem
     */
    'is_docker': boolean;
    /**
     * 
     * @type {number}
     * @memberof AppBuildTelemetrySystem
     */
    'cores'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AppBuildTelemetrySystem
     */
    'ram_size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AppBuildTelemetrySystem
     */
    'disk_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AppBuildTelemetrySystem
     */
    'cpu_flags': string;
}
/**
 * 
 * @export
 * @interface AppFeaturesTelemetry
 */
export interface AppFeaturesTelemetry {
    /**
     * 
     * @type {boolean}
     * @memberof AppFeaturesTelemetry
     */
    'debug': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppFeaturesTelemetry
     */
    'web_feature': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppFeaturesTelemetry
     */
    'service_debug_feature': boolean;
}
/**
 * 
 * @export
 * @interface Batch
 */
export interface Batch {
    /**
     * 
     * @type {Array<ExtendedPointId>}
     * @memberof Batch
     */
    'ids': Array<ExtendedPointId>;
    /**
     * 
     * @type {BatchVectorStruct}
     * @memberof Batch
     */
    'vectors': BatchVectorStruct;
    /**
     * 
     * @type {Array<BatchPayloadsInner>}
     * @memberof Batch
     */
    'payloads'?: Array<BatchPayloadsInner> | null;
}
/**
 * 
 * @export
 * @interface BatchPayloadsInner
 */
export interface BatchPayloadsInner {
}
/**
 * 
 * @export
 * @interface BatchVectorStruct
 */
export interface BatchVectorStruct {
}
/**
 * Operation for performing changes of collection aliases. Alias changes are atomic, meaning that no collection modifications can happen between alias operations.
 * @export
 * @interface ChangeAliasesOperation
 */
export interface ChangeAliasesOperation {
    /**
     * 
     * @type {Array<AliasOperations>}
     * @memberof ChangeAliasesOperation
     */
    'actions': Array<AliasOperations>;
}
/**
 * 
 * @export
 * @interface ClusterConfigTelemetry
 */
export interface ClusterConfigTelemetry {
    /**
     * 
     * @type {number}
     * @memberof ClusterConfigTelemetry
     */
    'grpc_timeout_ms': number;
    /**
     * 
     * @type {P2pConfigTelemetry}
     * @memberof ClusterConfigTelemetry
     */
    'p2p': P2pConfigTelemetry;
    /**
     * 
     * @type {ConsensusConfigTelemetry}
     * @memberof ClusterConfigTelemetry
     */
    'consensus': ConsensusConfigTelemetry;
}
/**
 * 
 * @export
 * @interface ClusterOperations
 */
export interface ClusterOperations {
    /**
     * 
     * @type {MoveShard}
     * @memberof ClusterOperations
     */
    'move_shard': MoveShard;
    /**
     * 
     * @type {MoveShard}
     * @memberof ClusterOperations
     */
    'replicate_shard': MoveShard;
    /**
     * 
     * @type {MoveShard}
     * @memberof ClusterOperations
     */
    'abort_transfer': MoveShard;
    /**
     * 
     * @type {Replica}
     * @memberof ClusterOperations
     */
    'drop_replica': Replica;
}
/**
 * @type ClusterStatus
 * Information about current cluster status and structure
 * @export
 */
export type ClusterStatus = ClusterStatusOneOf | ClusterStatusOneOf1;

/**
 * 
 * @export
 * @interface ClusterStatus200Response
 */
export interface ClusterStatus200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof ClusterStatus200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterStatus200Response
     */
    'status'?: ClusterStatus200ResponseStatusEnum;
    /**
     * 
     * @type {ClusterStatus}
     * @memberof ClusterStatus200Response
     */
    'result'?: ClusterStatus;
}

export const ClusterStatus200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type ClusterStatus200ResponseStatusEnum = typeof ClusterStatus200ResponseStatusEnum[keyof typeof ClusterStatus200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ClusterStatusOneOf
 */
export interface ClusterStatusOneOf {
    /**
     * 
     * @type {string}
     * @memberof ClusterStatusOneOf
     */
    'status': ClusterStatusOneOfStatusEnum;
}

export const ClusterStatusOneOfStatusEnum = {
    Disabled: 'disabled'
} as const;

export type ClusterStatusOneOfStatusEnum = typeof ClusterStatusOneOfStatusEnum[keyof typeof ClusterStatusOneOfStatusEnum];

/**
 * Description of enabled cluster
 * @export
 * @interface ClusterStatusOneOf1
 */
export interface ClusterStatusOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ClusterStatusOneOf1
     */
    'status': ClusterStatusOneOf1StatusEnum;
    /**
     * ID of this peer
     * @type {number}
     * @memberof ClusterStatusOneOf1
     */
    'peer_id': number;
    /**
     * Peers composition of the cluster with main information
     * @type {{ [key: string]: PeerInfo; }}
     * @memberof ClusterStatusOneOf1
     */
    'peers': { [key: string]: PeerInfo; };
    /**
     * 
     * @type {RaftInfo}
     * @memberof ClusterStatusOneOf1
     */
    'raft_info': RaftInfo;
    /**
     * 
     * @type {ConsensusThreadStatus}
     * @memberof ClusterStatusOneOf1
     */
    'consensus_thread_status': ConsensusThreadStatus;
    /**
     * Consequent failures of message send operations in consensus by peer address. On the first success to send to that peer - entry is removed from this hashmap.
     * @type {{ [key: string]: MessageSendErrors; }}
     * @memberof ClusterStatusOneOf1
     */
    'message_send_failures': { [key: string]: MessageSendErrors; };
}

export const ClusterStatusOneOf1StatusEnum = {
    Enabled: 'enabled'
} as const;

export type ClusterStatusOneOf1StatusEnum = typeof ClusterStatusOneOf1StatusEnum[keyof typeof ClusterStatusOneOf1StatusEnum];

/**
 * 
 * @export
 * @interface ClusterStatusTelemetry
 */
export interface ClusterStatusTelemetry {
    /**
     * 
     * @type {number}
     * @memberof ClusterStatusTelemetry
     */
    'number_of_peers': number;
    /**
     * 
     * @type {number}
     * @memberof ClusterStatusTelemetry
     */
    'term': number;
    /**
     * 
     * @type {number}
     * @memberof ClusterStatusTelemetry
     */
    'commit': number;
    /**
     * 
     * @type {number}
     * @memberof ClusterStatusTelemetry
     */
    'pending_operations': number;
    /**
     * 
     * @type {ClusterStatusTelemetryRole}
     * @memberof ClusterStatusTelemetry
     */
    'role'?: ClusterStatusTelemetryRole;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterStatusTelemetry
     */
    'is_voter': boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterStatusTelemetry
     */
    'peer_id'?: number | null;
    /**
     * 
     * @type {ConsensusThreadStatus}
     * @memberof ClusterStatusTelemetry
     */
    'consensus_thread_status': ConsensusThreadStatus;
}
/**
 * 
 * @export
 * @interface ClusterStatusTelemetryRole
 */
export interface ClusterStatusTelemetryRole {
}
/**
 * 
 * @export
 * @interface ClusterTelemetry
 */
export interface ClusterTelemetry {
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTelemetry
     */
    'enabled': boolean;
    /**
     * 
     * @type {ClusterTelemetryStatus}
     * @memberof ClusterTelemetry
     */
    'status'?: ClusterTelemetryStatus;
    /**
     * 
     * @type {ClusterTelemetryConfig}
     * @memberof ClusterTelemetry
     */
    'config'?: ClusterTelemetryConfig;
}
/**
 * 
 * @export
 * @interface ClusterTelemetryConfig
 */
export interface ClusterTelemetryConfig {
    /**
     * 
     * @type {number}
     * @memberof ClusterTelemetryConfig
     */
    'grpc_timeout_ms': number;
    /**
     * 
     * @type {P2pConfigTelemetry}
     * @memberof ClusterTelemetryConfig
     */
    'p2p': P2pConfigTelemetry;
    /**
     * 
     * @type {ConsensusConfigTelemetry}
     * @memberof ClusterTelemetryConfig
     */
    'consensus': ConsensusConfigTelemetry;
}
/**
 * 
 * @export
 * @interface ClusterTelemetryStatus
 */
export interface ClusterTelemetryStatus {
    /**
     * 
     * @type {number}
     * @memberof ClusterTelemetryStatus
     */
    'number_of_peers': number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTelemetryStatus
     */
    'term': number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTelemetryStatus
     */
    'commit': number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTelemetryStatus
     */
    'pending_operations': number;
    /**
     * 
     * @type {ClusterStatusTelemetryRole}
     * @memberof ClusterTelemetryStatus
     */
    'role'?: ClusterStatusTelemetryRole;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTelemetryStatus
     */
    'is_voter': boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterTelemetryStatus
     */
    'peer_id'?: number | null;
    /**
     * 
     * @type {ConsensusThreadStatus}
     * @memberof ClusterTelemetryStatus
     */
    'consensus_thread_status': ConsensusThreadStatus;
}
/**
 * Current clustering distribution for the collection
 * @export
 * @interface CollectionClusterInfo
 */
export interface CollectionClusterInfo {
    /**
     * ID of this peer
     * @type {number}
     * @memberof CollectionClusterInfo
     */
    'peer_id': number;
    /**
     * Total number of shards
     * @type {number}
     * @memberof CollectionClusterInfo
     */
    'shard_count': number;
    /**
     * Local shards
     * @type {Array<LocalShardInfo>}
     * @memberof CollectionClusterInfo
     */
    'local_shards': Array<LocalShardInfo>;
    /**
     * Remote shards
     * @type {Array<RemoteShardInfo>}
     * @memberof CollectionClusterInfo
     */
    'remote_shards': Array<RemoteShardInfo>;
    /**
     * Shard transfers
     * @type {Array<ShardTransferInfo>}
     * @memberof CollectionClusterInfo
     */
    'shard_transfers': Array<ShardTransferInfo>;
}
/**
 * 
 * @export
 * @interface CollectionClusterInfo200Response
 */
export interface CollectionClusterInfo200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof CollectionClusterInfo200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof CollectionClusterInfo200Response
     */
    'status'?: CollectionClusterInfo200ResponseStatusEnum;
    /**
     * 
     * @type {CollectionClusterInfo}
     * @memberof CollectionClusterInfo200Response
     */
    'result'?: CollectionClusterInfo;
}

export const CollectionClusterInfo200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type CollectionClusterInfo200ResponseStatusEnum = typeof CollectionClusterInfo200ResponseStatusEnum[keyof typeof CollectionClusterInfo200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface CollectionConfig
 */
export interface CollectionConfig {
    /**
     * 
     * @type {CollectionParams}
     * @memberof CollectionConfig
     */
    'params': CollectionParams;
    /**
     * 
     * @type {HnswConfig}
     * @memberof CollectionConfig
     */
    'hnsw_config': HnswConfig;
    /**
     * 
     * @type {OptimizersConfig}
     * @memberof CollectionConfig
     */
    'optimizer_config': OptimizersConfig;
    /**
     * 
     * @type {WalConfig}
     * @memberof CollectionConfig
     */
    'wal_config': WalConfig;
    /**
     * 
     * @type {CollectionConfigQuantizationConfig}
     * @memberof CollectionConfig
     */
    'quantization_config'?: CollectionConfigQuantizationConfig;
}
/**
 * 
 * @export
 * @interface CollectionConfigQuantizationConfig
 */
export interface CollectionConfigQuantizationConfig {
    /**
     * 
     * @type {ScalarQuantizationConfig}
     * @memberof CollectionConfigQuantizationConfig
     */
    'scalar': ScalarQuantizationConfig;
    /**
     * 
     * @type {ProductQuantizationConfig}
     * @memberof CollectionConfigQuantizationConfig
     */
    'product': ProductQuantizationConfig;
}
/**
 * 
 * @export
 * @interface CollectionDescription
 */
export interface CollectionDescription {
    /**
     * 
     * @type {string}
     * @memberof CollectionDescription
     */
    'name': string;
}
/**
 * Current statistics and configuration of the collection
 * @export
 * @interface CollectionInfo
 */
export interface CollectionInfo {
    /**
     * 
     * @type {CollectionStatus}
     * @memberof CollectionInfo
     */
    'status': CollectionStatus;
    /**
     * 
     * @type {OptimizersStatus}
     * @memberof CollectionInfo
     */
    'optimizer_status': OptimizersStatus;
    /**
     * Number of vectors in collection All vectors in collection are available for querying Calculated as `points_count x vectors_per_point` Where `vectors_per_point` is a number of named vectors in schema
     * @type {number}
     * @memberof CollectionInfo
     */
    'vectors_count': number;
    /**
     * Number of indexed vectors in the collection. Indexed vectors in large segments are faster to query, as it is stored in vector index (HNSW)
     * @type {number}
     * @memberof CollectionInfo
     */
    'indexed_vectors_count': number;
    /**
     * Number of points (vectors + payloads) in collection Each point could be accessed by unique id
     * @type {number}
     * @memberof CollectionInfo
     */
    'points_count': number;
    /**
     * Number of segments in collection. Each segment has independent vector as payload indexes
     * @type {number}
     * @memberof CollectionInfo
     */
    'segments_count': number;
    /**
     * 
     * @type {CollectionConfig}
     * @memberof CollectionInfo
     */
    'config': CollectionConfig;
    /**
     * Types of stored payload
     * @type {{ [key: string]: PayloadIndexInfo; }}
     * @memberof CollectionInfo
     */
    'payload_schema': { [key: string]: PayloadIndexInfo; };
}


/**
 * 
 * @export
 * @interface CollectionParams
 */
export interface CollectionParams {
    /**
     * 
     * @type {VectorsConfig}
     * @memberof CollectionParams
     */
    'vectors': VectorsConfig;
    /**
     * Number of shards the collection has
     * @type {number}
     * @memberof CollectionParams
     */
    'shard_number'?: number;
    /**
     * Number of replicas for each shard
     * @type {number}
     * @memberof CollectionParams
     */
    'replication_factor'?: number;
    /**
     * Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact.
     * @type {number}
     * @memberof CollectionParams
     */
    'write_consistency_factor'?: number;
    /**
     * If true - point\'s payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM.
     * @type {boolean}
     * @memberof CollectionParams
     */
    'on_disk_payload'?: boolean;
}
/**
 * 
 * @export
 * @interface CollectionParamsDiff
 */
export interface CollectionParamsDiff {
    /**
     * Number of replicas for each shard
     * @type {number}
     * @memberof CollectionParamsDiff
     */
    'replication_factor'?: number | null;
    /**
     * Minimal number successful responses from replicas to consider operation successful
     * @type {number}
     * @memberof CollectionParamsDiff
     */
    'write_consistency_factor'?: number | null;
}
/**
 * Current state of the collection. `Green` - all good. `Yellow` - optimization is running, `Red` - some operations failed and was not recovered
 * @export
 * @enum {string}
 */

export const CollectionStatus = {
    Green: 'green',
    Yellow: 'yellow',
    Red: 'red'
} as const;

export type CollectionStatus = typeof CollectionStatus[keyof typeof CollectionStatus];


/**
 * 
 * @export
 * @interface CollectionTelemetry
 */
export interface CollectionTelemetry {
    /**
     * 
     * @type {string}
     * @memberof CollectionTelemetry
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof CollectionTelemetry
     */
    'init_time_ms': number;
    /**
     * 
     * @type {CollectionConfig}
     * @memberof CollectionTelemetry
     */
    'config': CollectionConfig;
    /**
     * 
     * @type {Array<ReplicaSetTelemetry>}
     * @memberof CollectionTelemetry
     */
    'shards': Array<ReplicaSetTelemetry>;
    /**
     * 
     * @type {Array<ShardTransferInfo>}
     * @memberof CollectionTelemetry
     */
    'transfers': Array<ShardTransferInfo>;
}
/**
 * 
 * @export
 * @interface CollectionTelemetryEnum
 */
export interface CollectionTelemetryEnum {
    /**
     * 
     * @type {string}
     * @memberof CollectionTelemetryEnum
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof CollectionTelemetryEnum
     */
    'init_time_ms': number;
    /**
     * 
     * @type {CollectionConfig}
     * @memberof CollectionTelemetryEnum
     */
    'config': CollectionConfig;
    /**
     * 
     * @type {Array<ReplicaSetTelemetry>}
     * @memberof CollectionTelemetryEnum
     */
    'shards': Array<ReplicaSetTelemetry>;
    /**
     * 
     * @type {Array<ShardTransferInfo>}
     * @memberof CollectionTelemetryEnum
     */
    'transfers': Array<ShardTransferInfo>;
    /**
     * 
     * @type {number}
     * @memberof CollectionTelemetryEnum
     */
    'vectors': number;
    /**
     * 
     * @type {OptimizersStatus}
     * @memberof CollectionTelemetryEnum
     */
    'optimizers_status': OptimizersStatus;
    /**
     * 
     * @type {CollectionParams}
     * @memberof CollectionTelemetryEnum
     */
    'params': CollectionParams;
}
/**
 * 
 * @export
 * @interface CollectionsAggregatedTelemetry
 */
export interface CollectionsAggregatedTelemetry {
    /**
     * 
     * @type {number}
     * @memberof CollectionsAggregatedTelemetry
     */
    'vectors': number;
    /**
     * 
     * @type {OptimizersStatus}
     * @memberof CollectionsAggregatedTelemetry
     */
    'optimizers_status': OptimizersStatus;
    /**
     * 
     * @type {CollectionParams}
     * @memberof CollectionsAggregatedTelemetry
     */
    'params': CollectionParams;
}
/**
 * 
 * @export
 * @interface CollectionsAliasesResponse
 */
export interface CollectionsAliasesResponse {
    /**
     * 
     * @type {Array<AliasDescription>}
     * @memberof CollectionsAliasesResponse
     */
    'aliases': Array<AliasDescription>;
}
/**
 * 
 * @export
 * @interface CollectionsResponse
 */
export interface CollectionsResponse {
    /**
     * 
     * @type {Array<CollectionDescription>}
     * @memberof CollectionsResponse
     */
    'collections': Array<CollectionDescription>;
}
/**
 * 
 * @export
 * @interface CollectionsTelemetry
 */
export interface CollectionsTelemetry {
    /**
     * 
     * @type {number}
     * @memberof CollectionsTelemetry
     */
    'number_of_collections': number;
    /**
     * 
     * @type {Array<CollectionTelemetryEnum>}
     * @memberof CollectionsTelemetry
     */
    'collections'?: Array<CollectionTelemetryEnum> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CompressionRatio = {
    X4: 'x4',
    X8: 'x8',
    X16: 'x16',
    X32: 'x32',
    X64: 'x64'
} as const;

export type CompressionRatio = typeof CompressionRatio[keyof typeof CompressionRatio];


/**
 * 
 * @export
 * @interface Condition
 */
export interface Condition {
    /**
     * Payload key
     * @type {string}
     * @memberof Condition
     */
    'key': string;
    /**
     * 
     * @type {FieldConditionMatch}
     * @memberof Condition
     */
    'match'?: FieldConditionMatch;
    /**
     * 
     * @type {FieldConditionRange}
     * @memberof Condition
     */
    'range'?: FieldConditionRange;
    /**
     * 
     * @type {FieldConditionGeoBoundingBox}
     * @memberof Condition
     */
    'geo_bounding_box'?: FieldConditionGeoBoundingBox;
    /**
     * 
     * @type {FieldConditionGeoRadius}
     * @memberof Condition
     */
    'geo_radius'?: FieldConditionGeoRadius;
    /**
     * 
     * @type {FieldConditionValuesCount}
     * @memberof Condition
     */
    'values_count'?: FieldConditionValuesCount;
    /**
     * 
     * @type {PayloadField}
     * @memberof Condition
     */
    'is_empty': PayloadField;
    /**
     * 
     * @type {PayloadField}
     * @memberof Condition
     */
    'is_null': PayloadField;
    /**
     * 
     * @type {Set<ExtendedPointId>}
     * @memberof Condition
     */
    'has_id': Set<ExtendedPointId>;
    /**
     * 
     * @type {Nested}
     * @memberof Condition
     */
    'nested': Nested;
    /**
     * At least one of those conditions should match
     * @type {Array<Condition>}
     * @memberof Condition
     */
    'should'?: Array<Condition> | null;
    /**
     * All conditions must match
     * @type {Array<Condition>}
     * @memberof Condition
     */
    'must'?: Array<Condition> | null;
    /**
     * All conditions must NOT match
     * @type {Array<Condition>}
     * @memberof Condition
     */
    'must_not'?: Array<Condition> | null;
}
/**
 * 
 * @export
 * @interface ConsensusConfigTelemetry
 */
export interface ConsensusConfigTelemetry {
    /**
     * 
     * @type {number}
     * @memberof ConsensusConfigTelemetry
     */
    'max_message_queue_size': number;
    /**
     * 
     * @type {number}
     * @memberof ConsensusConfigTelemetry
     */
    'tick_period_ms': number;
    /**
     * 
     * @type {number}
     * @memberof ConsensusConfigTelemetry
     */
    'bootstrap_timeout_sec': number;
}
/**
 * @type ConsensusThreadStatus
 * Information about current consensus thread status
 * @export
 */
export type ConsensusThreadStatus = ConsensusThreadStatusOneOf | ConsensusThreadStatusOneOf1 | ConsensusThreadStatusOneOf2;

/**
 * 
 * @export
 * @interface ConsensusThreadStatusOneOf
 */
export interface ConsensusThreadStatusOneOf {
    /**
     * 
     * @type {string}
     * @memberof ConsensusThreadStatusOneOf
     */
    'consensus_thread_status': ConsensusThreadStatusOneOfConsensusThreadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ConsensusThreadStatusOneOf
     */
    'last_update': string;
}

export const ConsensusThreadStatusOneOfConsensusThreadStatusEnum = {
    Working: 'working'
} as const;

export type ConsensusThreadStatusOneOfConsensusThreadStatusEnum = typeof ConsensusThreadStatusOneOfConsensusThreadStatusEnum[keyof typeof ConsensusThreadStatusOneOfConsensusThreadStatusEnum];

/**
 * 
 * @export
 * @interface ConsensusThreadStatusOneOf1
 */
export interface ConsensusThreadStatusOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ConsensusThreadStatusOneOf1
     */
    'consensus_thread_status': ConsensusThreadStatusOneOf1ConsensusThreadStatusEnum;
}

export const ConsensusThreadStatusOneOf1ConsensusThreadStatusEnum = {
    Stopped: 'stopped'
} as const;

export type ConsensusThreadStatusOneOf1ConsensusThreadStatusEnum = typeof ConsensusThreadStatusOneOf1ConsensusThreadStatusEnum[keyof typeof ConsensusThreadStatusOneOf1ConsensusThreadStatusEnum];

/**
 * 
 * @export
 * @interface ConsensusThreadStatusOneOf2
 */
export interface ConsensusThreadStatusOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof ConsensusThreadStatusOneOf2
     */
    'consensus_thread_status': ConsensusThreadStatusOneOf2ConsensusThreadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ConsensusThreadStatusOneOf2
     */
    'err': string;
}

export const ConsensusThreadStatusOneOf2ConsensusThreadStatusEnum = {
    StoppedWithErr: 'stopped_with_err'
} as const;

export type ConsensusThreadStatusOneOf2ConsensusThreadStatusEnum = typeof ConsensusThreadStatusOneOf2ConsensusThreadStatusEnum[keyof typeof ConsensusThreadStatusOneOf2ConsensusThreadStatusEnum];

/**
 * 
 * @export
 * @interface CountPoints200Response
 */
export interface CountPoints200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof CountPoints200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof CountPoints200Response
     */
    'status'?: CountPoints200ResponseStatusEnum;
    /**
     * 
     * @type {CountResult}
     * @memberof CountPoints200Response
     */
    'result'?: CountResult;
}

export const CountPoints200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type CountPoints200ResponseStatusEnum = typeof CountPoints200ResponseStatusEnum[keyof typeof CountPoints200ResponseStatusEnum];

/**
 * Count Request Counts the number of points which satisfy the given filter. If filter is not provided, the count of all points in the collection will be returned.
 * @export
 * @interface CountRequest
 */
export interface CountRequest {
    /**
     * 
     * @type {SearchRequestFilter}
     * @memberof CountRequest
     */
    'filter'?: SearchRequestFilter;
    /**
     * If true, count exact number of points. If false, count approximate number of points faster. Approximate count might be unreliable during the indexing process. Default: true
     * @type {boolean}
     * @memberof CountRequest
     */
    'exact'?: boolean;
}
/**
 * 
 * @export
 * @interface CountResult
 */
export interface CountResult {
    /**
     * Number of points which satisfy the conditions
     * @type {number}
     * @memberof CountResult
     */
    'count': number;
}
/**
 * Create alternative name for a collection. Collection will be available under both names for search, retrieve,
 * @export
 * @interface CreateAlias
 */
export interface CreateAlias {
    /**
     * 
     * @type {string}
     * @memberof CreateAlias
     */
    'collection_name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAlias
     */
    'alias_name': string;
}
/**
 * 
 * @export
 * @interface CreateAliasOperation
 */
export interface CreateAliasOperation {
    /**
     * 
     * @type {CreateAlias}
     * @memberof CreateAliasOperation
     */
    'create_alias': CreateAlias;
}
/**
 * Operation for creating new collection and (optionally) specify index params
 * @export
 * @interface CreateCollection
 */
export interface CreateCollection {
    /**
     * 
     * @type {VectorsConfig}
     * @memberof CreateCollection
     */
    'vectors': VectorsConfig;
    /**
     * Number of shards in collection. Default is 1 for standalone, otherwise equal to the number of nodes Minimum is 1
     * @type {number}
     * @memberof CreateCollection
     */
    'shard_number'?: number | null;
    /**
     * Number of shards replicas. Default is 1 Minimum is 1
     * @type {number}
     * @memberof CreateCollection
     */
    'replication_factor'?: number | null;
    /**
     * Defines how many replicas should apply the operation for us to consider it successful. Increasing this number will make the collection more resilient to inconsistencies, but will also make it fail if not enough replicas are available. Does not have any performance impact.
     * @type {number}
     * @memberof CreateCollection
     */
    'write_consistency_factor'?: number | null;
    /**
     * If true - point\'s payload will not be stored in memory. It will be read from the disk every time it is requested. This setting saves RAM by (slightly) increasing the response time. Note: those payload values that are involved in filtering and are indexed - remain in RAM.
     * @type {boolean}
     * @memberof CreateCollection
     */
    'on_disk_payload'?: boolean | null;
    /**
     * 
     * @type {CreateCollectionHnswConfig}
     * @memberof CreateCollection
     */
    'hnsw_config'?: CreateCollectionHnswConfig;
    /**
     * 
     * @type {CreateCollectionWalConfig}
     * @memberof CreateCollection
     */
    'wal_config'?: CreateCollectionWalConfig;
    /**
     * 
     * @type {CreateCollectionOptimizersConfig}
     * @memberof CreateCollection
     */
    'optimizers_config'?: CreateCollectionOptimizersConfig;
    /**
     * 
     * @type {CreateCollectionInitFrom}
     * @memberof CreateCollection
     */
    'init_from'?: CreateCollectionInitFrom;
    /**
     * 
     * @type {CreateCollectionQuantizationConfig}
     * @memberof CreateCollection
     */
    'quantization_config'?: CreateCollectionQuantizationConfig;
}
/**
 * Custom params for HNSW index. If none - values from service configuration file are used.
 * @export
 * @interface CreateCollectionHnswConfig
 */
export interface CreateCollectionHnswConfig {
    /**
     * Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
     * @type {number}
     * @memberof CreateCollectionHnswConfig
     */
    'm'?: number | null;
    /**
     * Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build the index.
     * @type {number}
     * @memberof CreateCollectionHnswConfig
     */
    'ef_construct'?: number | null;
    /**
     * Minimal size (in kilobytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won\'t be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof CreateCollectionHnswConfig
     */
    'full_scan_threshold'?: number | null;
    /**
     * Number of parallel threads used for background index building. If 0 - auto selection.
     * @type {number}
     * @memberof CreateCollectionHnswConfig
     */
    'max_indexing_threads'?: number | null;
    /**
     * Store HNSW index on disk. If set to false, the index will be stored in RAM. Default: false
     * @type {boolean}
     * @memberof CreateCollectionHnswConfig
     */
    'on_disk'?: boolean | null;
    /**
     * Custom M param for additional payload-aware HNSW links. If not set, default M will be used.
     * @type {number}
     * @memberof CreateCollectionHnswConfig
     */
    'payload_m'?: number | null;
}
/**
 * Specify other collection to copy data from.
 * @export
 * @interface CreateCollectionInitFrom
 */
export interface CreateCollectionInitFrom {
    /**
     * 
     * @type {string}
     * @memberof CreateCollectionInitFrom
     */
    'collection': string;
}
/**
 * Custom params for Optimizers.  If none - values from service configuration file are used.
 * @export
 * @interface CreateCollectionOptimizersConfig
 */
export interface CreateCollectionOptimizersConfig {
    /**
     * The minimal fraction of deleted vectors in a segment, required to perform segment optimization
     * @type {number}
     * @memberof CreateCollectionOptimizersConfig
     */
    'deleted_threshold'?: number | null;
    /**
     * The minimal number of vectors in a segment, required to perform segment optimization
     * @type {number}
     * @memberof CreateCollectionOptimizersConfig
     */
    'vacuum_min_vector_number'?: number | null;
    /**
     * Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS  It is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads If `default_segment_number = 0`, will be automatically selected by the number of available CPUs
     * @type {number}
     * @memberof CreateCollectionOptimizersConfig
     */
    'default_segment_number'?: number | null;
    /**
     * Do not create segments larger this size (in kilobytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.  If indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof CreateCollectionOptimizersConfig
     */
    'max_segment_size'?: number | null;
    /**
     * Maximum size (in kilobytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.  Memmap storage is disabled by default, to enable it, set this threshold to a reasonable value.  To disable memmap storage, set this to `0`.  Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof CreateCollectionOptimizersConfig
     */
    'memmap_threshold'?: number | null;
    /**
     * Maximum size (in kilobytes) of vectors allowed for plain index, exceeding this threshold will enable vector indexing  Default value is 20,000, based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md>.  To disable vector indexing, set to `0`.  Note: 1kB = 1 vector of size 256.
     * @type {number}
     * @memberof CreateCollectionOptimizersConfig
     */
    'indexing_threshold'?: number | null;
    /**
     * Minimum interval between forced flushes.
     * @type {number}
     * @memberof CreateCollectionOptimizersConfig
     */
    'flush_interval_sec'?: number | null;
    /**
     * Maximum available threads for optimization workers
     * @type {number}
     * @memberof CreateCollectionOptimizersConfig
     */
    'max_optimization_threads'?: number | null;
}
/**
 * Quantization parameters. If none - quantization is disabled.
 * @export
 * @interface CreateCollectionQuantizationConfig
 */
export interface CreateCollectionQuantizationConfig {
    /**
     * 
     * @type {ScalarQuantizationConfig}
     * @memberof CreateCollectionQuantizationConfig
     */
    'scalar': ScalarQuantizationConfig;
    /**
     * 
     * @type {ProductQuantizationConfig}
     * @memberof CreateCollectionQuantizationConfig
     */
    'product': ProductQuantizationConfig;
}
/**
 * Custom params for WAL. If none - values from service configuration file are used.
 * @export
 * @interface CreateCollectionWalConfig
 */
export interface CreateCollectionWalConfig {
    /**
     * Size of a single WAL segment in MB
     * @type {number}
     * @memberof CreateCollectionWalConfig
     */
    'wal_capacity_mb'?: number | null;
    /**
     * Number of WAL segments to create ahead of actually used ones
     * @type {number}
     * @memberof CreateCollectionWalConfig
     */
    'wal_segments_ahead'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateFieldIndex
 */
export interface CreateFieldIndex {
    /**
     * 
     * @type {string}
     * @memberof CreateFieldIndex
     */
    'field_name': string;
    /**
     * 
     * @type {CreateFieldIndexFieldSchema}
     * @memberof CreateFieldIndex
     */
    'field_schema'?: CreateFieldIndexFieldSchema;
}
/**
 * 
 * @export
 * @interface CreateFieldIndex200Response
 */
export interface CreateFieldIndex200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof CreateFieldIndex200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateFieldIndex200Response
     */
    'status'?: CreateFieldIndex200ResponseStatusEnum;
    /**
     * 
     * @type {UpdateResult}
     * @memberof CreateFieldIndex200Response
     */
    'result'?: UpdateResult;
}

export const CreateFieldIndex200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type CreateFieldIndex200ResponseStatusEnum = typeof CreateFieldIndex200ResponseStatusEnum[keyof typeof CreateFieldIndex200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface CreateFieldIndexFieldSchema
 */
export interface CreateFieldIndexFieldSchema {
    /**
     * 
     * @type {TextIndexType}
     * @memberof CreateFieldIndexFieldSchema
     */
    'type': TextIndexType;
    /**
     * 
     * @type {TokenizerType}
     * @memberof CreateFieldIndexFieldSchema
     */
    'tokenizer'?: TokenizerType;
    /**
     * 
     * @type {number}
     * @memberof CreateFieldIndexFieldSchema
     */
    'min_token_len'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateFieldIndexFieldSchema
     */
    'max_token_len'?: number | null;
    /**
     * If true, lowercase all tokens. Default: true
     * @type {boolean}
     * @memberof CreateFieldIndexFieldSchema
     */
    'lowercase'?: boolean | null;
}


/**
 * 
 * @export
 * @interface CreateSnapshot200Response
 */
export interface CreateSnapshot200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof CreateSnapshot200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateSnapshot200Response
     */
    'status'?: CreateSnapshot200ResponseStatusEnum;
    /**
     * 
     * @type {SnapshotDescription}
     * @memberof CreateSnapshot200Response
     */
    'result'?: SnapshotDescription;
}

export const CreateSnapshot200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type CreateSnapshot200ResponseStatusEnum = typeof CreateSnapshot200ResponseStatusEnum[keyof typeof CreateSnapshot200ResponseStatusEnum];

/**
 * Delete alias if exists
 * @export
 * @interface DeleteAlias
 */
export interface DeleteAlias {
    /**
     * 
     * @type {string}
     * @memberof DeleteAlias
     */
    'alias_name': string;
}
/**
 * Delete alias if exists
 * @export
 * @interface DeleteAliasOperation
 */
export interface DeleteAliasOperation {
    /**
     * 
     * @type {DeleteAlias}
     * @memberof DeleteAliasOperation
     */
    'delete_alias': DeleteAlias;
}
/**
 * 
 * @export
 * @interface DeletePayload
 */
export interface DeletePayload {
    /**
     * List of payload keys to remove from payload
     * @type {Array<string>}
     * @memberof DeletePayload
     */
    'keys': Array<string>;
    /**
     * Deletes values from each point in this list
     * @type {Array<ExtendedPointId>}
     * @memberof DeletePayload
     */
    'points'?: Array<ExtendedPointId> | null;
    /**
     * 
     * @type {DeletePayloadFilter}
     * @memberof DeletePayload
     */
    'filter'?: DeletePayloadFilter;
}
/**
 * Deletes values from points that satisfy this filter condition
 * @export
 * @interface DeletePayloadFilter
 */
export interface DeletePayloadFilter {
    /**
     * At least one of those conditions should match
     * @type {Array<Condition>}
     * @memberof DeletePayloadFilter
     */
    'should'?: Array<Condition> | null;
    /**
     * All conditions must match
     * @type {Array<Condition>}
     * @memberof DeletePayloadFilter
     */
    'must'?: Array<Condition> | null;
    /**
     * All conditions must NOT match
     * @type {Array<Condition>}
     * @memberof DeletePayloadFilter
     */
    'must_not'?: Array<Condition> | null;
}
/**
 * 
 * @export
 * @interface DeleteVectors
 */
export interface DeleteVectors {
    /**
     * Deletes values from each point in this list
     * @type {Array<ExtendedPointId>}
     * @memberof DeleteVectors
     */
    'points'?: Array<ExtendedPointId> | null;
    /**
     * 
     * @type {DeletePayloadFilter}
     * @memberof DeleteVectors
     */
    'filter'?: DeletePayloadFilter;
    /**
     * Vector names
     * @type {Set<string>}
     * @memberof DeleteVectors
     */
    'vector': Set<string>;
}
/**
 * Type of internal tags, build from payload Distance function types used to compare vectors
 * @export
 * @enum {string}
 */

export const Distance = {
    Cosine: 'Cosine',
    Euclid: 'Euclid',
    Dot: 'Dot'
} as const;

export type Distance = typeof Distance[keyof typeof Distance];


/**
 * 
 * @export
 * @interface DropReplicaOperation
 */
export interface DropReplicaOperation {
    /**
     * 
     * @type {Replica}
     * @memberof DropReplicaOperation
     */
    'drop_replica': Replica;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof ErrorResponse
     */
    'time'?: number;
    /**
     * 
     * @type {ErrorResponseStatus}
     * @memberof ErrorResponse
     */
    'status'?: ErrorResponseStatus;
    /**
     * 
     * @type {object}
     * @memberof ErrorResponse
     */
    'result'?: object | null;
}
/**
 * 
 * @export
 * @interface ErrorResponseStatus
 */
export interface ErrorResponseStatus {
    /**
     * Description of the occurred error.
     * @type {string}
     * @memberof ErrorResponseStatus
     */
    'error'?: string;
}
/**
 * Type, used for specifying point ID in user interface
 * @export
 * @interface ExtendedPointId
 */
export interface ExtendedPointId {
}
/**
 * All possible payload filtering conditions
 * @export
 * @interface FieldCondition
 */
export interface FieldCondition {
    /**
     * Payload key
     * @type {string}
     * @memberof FieldCondition
     */
    'key': string;
    /**
     * 
     * @type {FieldConditionMatch}
     * @memberof FieldCondition
     */
    'match'?: FieldConditionMatch;
    /**
     * 
     * @type {FieldConditionRange}
     * @memberof FieldCondition
     */
    'range'?: FieldConditionRange;
    /**
     * 
     * @type {FieldConditionGeoBoundingBox}
     * @memberof FieldCondition
     */
    'geo_bounding_box'?: FieldConditionGeoBoundingBox;
    /**
     * 
     * @type {FieldConditionGeoRadius}
     * @memberof FieldCondition
     */
    'geo_radius'?: FieldConditionGeoRadius;
    /**
     * 
     * @type {FieldConditionValuesCount}
     * @memberof FieldCondition
     */
    'values_count'?: FieldConditionValuesCount;
}
/**
 * Check if points geo location lies in a given area
 * @export
 * @interface FieldConditionGeoBoundingBox
 */
export interface FieldConditionGeoBoundingBox {
    /**
     * 
     * @type {GeoPoint}
     * @memberof FieldConditionGeoBoundingBox
     */
    'top_left': GeoPoint;
    /**
     * 
     * @type {GeoPoint}
     * @memberof FieldConditionGeoBoundingBox
     */
    'bottom_right': GeoPoint;
}
/**
 * Check if geo point is within a given radius
 * @export
 * @interface FieldConditionGeoRadius
 */
export interface FieldConditionGeoRadius {
    /**
     * 
     * @type {GeoPoint}
     * @memberof FieldConditionGeoRadius
     */
    'center': GeoPoint;
    /**
     * Radius of the area in meters
     * @type {number}
     * @memberof FieldConditionGeoRadius
     */
    'radius': number;
}
/**
 * Check if point has field with a given value
 * @export
 * @interface FieldConditionMatch
 */
export interface FieldConditionMatch {
    /**
     * 
     * @type {ValueVariants}
     * @memberof FieldConditionMatch
     */
    'value': ValueVariants;
    /**
     * 
     * @type {string}
     * @memberof FieldConditionMatch
     */
    'text': string;
    /**
     * 
     * @type {AnyVariants}
     * @memberof FieldConditionMatch
     */
    'any': AnyVariants;
}
/**
 * Check if points value lies in a given range
 * @export
 * @interface FieldConditionRange
 */
export interface FieldConditionRange {
    /**
     * point.key < range.lt
     * @type {number}
     * @memberof FieldConditionRange
     */
    'lt'?: number | null;
    /**
     * point.key > range.gt
     * @type {number}
     * @memberof FieldConditionRange
     */
    'gt'?: number | null;
    /**
     * point.key >= range.gte
     * @type {number}
     * @memberof FieldConditionRange
     */
    'gte'?: number | null;
    /**
     * point.key <= range.lte
     * @type {number}
     * @memberof FieldConditionRange
     */
    'lte'?: number | null;
}
/**
 * Check number of values of the field
 * @export
 * @interface FieldConditionValuesCount
 */
export interface FieldConditionValuesCount {
    /**
     * point.key.length() < values_count.lt
     * @type {number}
     * @memberof FieldConditionValuesCount
     */
    'lt'?: number | null;
    /**
     * point.key.length() > values_count.gt
     * @type {number}
     * @memberof FieldConditionValuesCount
     */
    'gt'?: number | null;
    /**
     * point.key.length() >= values_count.gte
     * @type {number}
     * @memberof FieldConditionValuesCount
     */
    'gte'?: number | null;
    /**
     * point.key.length() <= values_count.lte
     * @type {number}
     * @memberof FieldConditionValuesCount
     */
    'lte'?: number | null;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * At least one of those conditions should match
     * @type {Array<Condition>}
     * @memberof Filter
     */
    'should'?: Array<Condition> | null;
    /**
     * All conditions must match
     * @type {Array<Condition>}
     * @memberof Filter
     */
    'must'?: Array<Condition> | null;
    /**
     * All conditions must NOT match
     * @type {Array<Condition>}
     * @memberof Filter
     */
    'must_not'?: Array<Condition> | null;
}
/**
 * 
 * @export
 * @interface FilterSelector
 */
export interface FilterSelector {
    /**
     * 
     * @type {Filter}
     * @memberof FilterSelector
     */
    'filter': Filter;
}
/**
 * Geo filter request  Matches coordinates inside the rectangle, described by coordinates of lop-left and bottom-right edges
 * @export
 * @interface GeoBoundingBox
 */
export interface GeoBoundingBox {
    /**
     * 
     * @type {GeoPoint}
     * @memberof GeoBoundingBox
     */
    'top_left': GeoPoint;
    /**
     * 
     * @type {GeoPoint}
     * @memberof GeoBoundingBox
     */
    'bottom_right': GeoPoint;
}
/**
 * Geo point payload schema
 * @export
 * @interface GeoPoint
 */
export interface GeoPoint {
    /**
     * 
     * @type {number}
     * @memberof GeoPoint
     */
    'lon': number;
    /**
     * 
     * @type {number}
     * @memberof GeoPoint
     */
    'lat': number;
}
/**
 * Geo filter request  Matches coordinates inside the circle of `radius` and center with coordinates `center`
 * @export
 * @interface GeoRadius
 */
export interface GeoRadius {
    /**
     * 
     * @type {GeoPoint}
     * @memberof GeoRadius
     */
    'center': GeoPoint;
    /**
     * Radius of the area in meters
     * @type {number}
     * @memberof GeoRadius
     */
    'radius': number;
}
/**
 * 
 * @export
 * @interface GetCollection200Response
 */
export interface GetCollection200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof GetCollection200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCollection200Response
     */
    'status'?: GetCollection200ResponseStatusEnum;
    /**
     * 
     * @type {CollectionInfo}
     * @memberof GetCollection200Response
     */
    'result'?: CollectionInfo;
}

export const GetCollection200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type GetCollection200ResponseStatusEnum = typeof GetCollection200ResponseStatusEnum[keyof typeof GetCollection200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetCollectionAliases200Response
 */
export interface GetCollectionAliases200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof GetCollectionAliases200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCollectionAliases200Response
     */
    'status'?: GetCollectionAliases200ResponseStatusEnum;
    /**
     * 
     * @type {CollectionsAliasesResponse}
     * @memberof GetCollectionAliases200Response
     */
    'result'?: CollectionsAliasesResponse;
}

export const GetCollectionAliases200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type GetCollectionAliases200ResponseStatusEnum = typeof GetCollectionAliases200ResponseStatusEnum[keyof typeof GetCollectionAliases200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetCollections200Response
 */
export interface GetCollections200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof GetCollections200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCollections200Response
     */
    'status'?: GetCollections200ResponseStatusEnum;
    /**
     * 
     * @type {CollectionsResponse}
     * @memberof GetCollections200Response
     */
    'result'?: CollectionsResponse;
}

export const GetCollections200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type GetCollections200ResponseStatusEnum = typeof GetCollections200ResponseStatusEnum[keyof typeof GetCollections200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetLocks200Response
 */
export interface GetLocks200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof GetLocks200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetLocks200Response
     */
    'status'?: GetLocks200ResponseStatusEnum;
    /**
     * 
     * @type {LocksOption}
     * @memberof GetLocks200Response
     */
    'result'?: LocksOption;
}

export const GetLocks200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type GetLocks200ResponseStatusEnum = typeof GetLocks200ResponseStatusEnum[keyof typeof GetLocks200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetPoint200Response
 */
export interface GetPoint200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof GetPoint200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetPoint200Response
     */
    'status'?: GetPoint200ResponseStatusEnum;
    /**
     * 
     * @type {Record}
     * @memberof GetPoint200Response
     */
    'result'?: Record;
}

export const GetPoint200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type GetPoint200ResponseStatusEnum = typeof GetPoint200ResponseStatusEnum[keyof typeof GetPoint200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetPoints200Response
 */
export interface GetPoints200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof GetPoints200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetPoints200Response
     */
    'status'?: GetPoints200ResponseStatusEnum;
    /**
     * 
     * @type {Array<Record>}
     * @memberof GetPoints200Response
     */
    'result'?: Array<Record>;
}

export const GetPoints200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type GetPoints200ResponseStatusEnum = typeof GetPoints200ResponseStatusEnum[keyof typeof GetPoints200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GroupId
 */
export interface GroupId {
}
/**
 * 
 * @export
 * @interface GroupsResult
 */
export interface GroupsResult {
    /**
     * 
     * @type {Array<PointGroup>}
     * @memberof GroupsResult
     */
    'groups': Array<PointGroup>;
}
/**
 * 
 * @export
 * @interface GrpcTelemetry
 */
export interface GrpcTelemetry {
    /**
     * 
     * @type {{ [key: string]: OperationDurationStatistics; }}
     * @memberof GrpcTelemetry
     */
    'responses': { [key: string]: OperationDurationStatistics; };
}
/**
 * ID-based filtering condition
 * @export
 * @interface HasIdCondition
 */
export interface HasIdCondition {
    /**
     * 
     * @type {Set<ExtendedPointId>}
     * @memberof HasIdCondition
     */
    'has_id': Set<ExtendedPointId>;
}
/**
 * Config of HNSW index
 * @export
 * @interface HnswConfig
 */
export interface HnswConfig {
    /**
     * Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
     * @type {number}
     * @memberof HnswConfig
     */
    'm': number;
    /**
     * Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.
     * @type {number}
     * @memberof HnswConfig
     */
    'ef_construct': number;
    /**
     * Minimal size (in KiloBytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won\'t be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof HnswConfig
     */
    'full_scan_threshold': number;
    /**
     * Number of parallel threads used for background index building. If 0 - auto selection.
     * @type {number}
     * @memberof HnswConfig
     */
    'max_indexing_threads'?: number;
    /**
     * Store HNSW index on disk. If set to false, index will be stored in RAM. Default: false
     * @type {boolean}
     * @memberof HnswConfig
     */
    'on_disk'?: boolean | null;
    /**
     * Custom M param for hnsw graph built for payload index. If not set, default M will be used.
     * @type {number}
     * @memberof HnswConfig
     */
    'payload_m'?: number | null;
}
/**
 * 
 * @export
 * @interface HnswConfigDiff
 */
export interface HnswConfigDiff {
    /**
     * Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
     * @type {number}
     * @memberof HnswConfigDiff
     */
    'm'?: number | null;
    /**
     * Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build the index.
     * @type {number}
     * @memberof HnswConfigDiff
     */
    'ef_construct'?: number | null;
    /**
     * Minimal size (in kilobytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won\'t be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof HnswConfigDiff
     */
    'full_scan_threshold'?: number | null;
    /**
     * Number of parallel threads used for background index building. If 0 - auto selection.
     * @type {number}
     * @memberof HnswConfigDiff
     */
    'max_indexing_threads'?: number | null;
    /**
     * Store HNSW index on disk. If set to false, the index will be stored in RAM. Default: false
     * @type {boolean}
     * @memberof HnswConfigDiff
     */
    'on_disk'?: boolean | null;
    /**
     * Custom M param for additional payload-aware HNSW links. If not set, default M will be used.
     * @type {number}
     * @memberof HnswConfigDiff
     */
    'payload_m'?: number | null;
}
/**
 * @type Indexes
 * Vector index configuration
 * @export
 */
export type Indexes = IndexesOneOf | IndexesOneOf1;

/**
 * Do not use any index, scan whole vector collection during search. Guarantee 100% precision, but may be time consuming on large collections.
 * @export
 * @interface IndexesOneOf
 */
export interface IndexesOneOf {
    /**
     * 
     * @type {string}
     * @memberof IndexesOneOf
     */
    'type': IndexesOneOfTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof IndexesOneOf
     */
    'options': object;
}

export const IndexesOneOfTypeEnum = {
    Plain: 'plain'
} as const;

export type IndexesOneOfTypeEnum = typeof IndexesOneOfTypeEnum[keyof typeof IndexesOneOfTypeEnum];

/**
 * Use filterable HNSW index for approximate search. Is very fast even on a very huge collections, but require additional space to store index and additional time to build it.
 * @export
 * @interface IndexesOneOf1
 */
export interface IndexesOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof IndexesOneOf1
     */
    'type': IndexesOneOf1TypeEnum;
    /**
     * 
     * @type {HnswConfig}
     * @memberof IndexesOneOf1
     */
    'options': HnswConfig;
}

export const IndexesOneOf1TypeEnum = {
    Hnsw: 'hnsw'
} as const;

export type IndexesOneOf1TypeEnum = typeof IndexesOneOf1TypeEnum[keyof typeof IndexesOneOf1TypeEnum];

/**
 * Operation for creating new collection and (optionally) specify index params
 * @export
 * @interface InitFrom
 */
export interface InitFrom {
    /**
     * 
     * @type {string}
     * @memberof InitFrom
     */
    'collection': string;
}
/**
 * Select points with empty payload for a specified field
 * @export
 * @interface IsEmptyCondition
 */
export interface IsEmptyCondition {
    /**
     * 
     * @type {PayloadField}
     * @memberof IsEmptyCondition
     */
    'is_empty': PayloadField;
}
/**
 * Select points with null payload for a specified field
 * @export
 * @interface IsNullCondition
 */
export interface IsNullCondition {
    /**
     * 
     * @type {PayloadField}
     * @memberof IsNullCondition
     */
    'is_null': PayloadField;
}
/**
 * 
 * @export
 * @interface ListSnapshots200Response
 */
export interface ListSnapshots200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof ListSnapshots200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListSnapshots200Response
     */
    'status'?: ListSnapshots200ResponseStatusEnum;
    /**
     * 
     * @type {Array<SnapshotDescription>}
     * @memberof ListSnapshots200Response
     */
    'result'?: Array<SnapshotDescription>;
}

export const ListSnapshots200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type ListSnapshots200ResponseStatusEnum = typeof ListSnapshots200ResponseStatusEnum[keyof typeof ListSnapshots200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface LocalShardInfo
 */
export interface LocalShardInfo {
    /**
     * Local shard id
     * @type {number}
     * @memberof LocalShardInfo
     */
    'shard_id': number;
    /**
     * Number of points in the shard
     * @type {number}
     * @memberof LocalShardInfo
     */
    'points_count': number;
    /**
     * 
     * @type {ReplicaState}
     * @memberof LocalShardInfo
     */
    'state': ReplicaState;
}


/**
 * 
 * @export
 * @interface LocalShardTelemetry
 */
export interface LocalShardTelemetry {
    /**
     * 
     * @type {string}
     * @memberof LocalShardTelemetry
     */
    'variant_name'?: string | null;
    /**
     * 
     * @type {Array<SegmentTelemetry>}
     * @memberof LocalShardTelemetry
     */
    'segments': Array<SegmentTelemetry>;
    /**
     * 
     * @type {OptimizerTelemetry}
     * @memberof LocalShardTelemetry
     */
    'optimizations': OptimizerTelemetry;
}
/**
 * 
 * @export
 * @interface LocksOption
 */
export interface LocksOption {
    /**
     * 
     * @type {string}
     * @memberof LocksOption
     */
    'error_message'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LocksOption
     */
    'write': boolean;
}
/**
 * Defines a location to use for looking up the vector. Specifies collection and vector field name.
 * @export
 * @interface LookupLocation
 */
export interface LookupLocation {
    /**
     * Name of the collection used for lookup
     * @type {string}
     * @memberof LookupLocation
     */
    'collection': string;
    /**
     * Optional name of the vector field within the collection. If not provided, the default vector field will be used.
     * @type {string}
     * @memberof LookupLocation
     */
    'vector'?: string | null;
}
/**
 * Match filter request
 * @export
 * @interface Match
 */
export interface Match {
    /**
     * 
     * @type {ValueVariants}
     * @memberof Match
     */
    'value': ValueVariants;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'text': string;
    /**
     * 
     * @type {AnyVariants}
     * @memberof Match
     */
    'any': AnyVariants;
}
/**
 * Exact match on any of the given values
 * @export
 * @interface MatchAny
 */
export interface MatchAny {
    /**
     * 
     * @type {AnyVariants}
     * @memberof MatchAny
     */
    'any': AnyVariants;
}
/**
 * Full-text match of the strings.
 * @export
 * @interface MatchText
 */
export interface MatchText {
    /**
     * 
     * @type {string}
     * @memberof MatchText
     */
    'text': string;
}
/**
 * Exact match of the given value
 * @export
 * @interface MatchValue
 */
export interface MatchValue {
    /**
     * 
     * @type {ValueVariants}
     * @memberof MatchValue
     */
    'value': ValueVariants;
}
/**
 * Message send failures for a particular peer
 * @export
 * @interface MessageSendErrors
 */
export interface MessageSendErrors {
    /**
     * 
     * @type {number}
     * @memberof MessageSendErrors
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof MessageSendErrors
     */
    'latest_error'?: string | null;
}
/**
 * 
 * @export
 * @interface MoveShard
 */
export interface MoveShard {
    /**
     * 
     * @type {number}
     * @memberof MoveShard
     */
    'shard_id': number;
    /**
     * 
     * @type {number}
     * @memberof MoveShard
     */
    'to_peer_id': number;
    /**
     * 
     * @type {number}
     * @memberof MoveShard
     */
    'from_peer_id': number;
}
/**
 * 
 * @export
 * @interface MoveShardOperation
 */
export interface MoveShardOperation {
    /**
     * 
     * @type {MoveShard}
     * @memberof MoveShardOperation
     */
    'move_shard': MoveShard;
}
/**
 * Vector data with name
 * @export
 * @interface NamedVector
 */
export interface NamedVector {
    /**
     * Name of vector data
     * @type {string}
     * @memberof NamedVector
     */
    'name': string;
    /**
     * Vector data
     * @type {Array<number>}
     * @memberof NamedVector
     */
    'vector': Array<number>;
}
/**
 * Vector data separator for named and unnamed modes Unanmed mode:  { \"vector\": [1.0, 2.0, 3.0] }  or named mode:  { \"vector\": { \"vector\": [1.0, 2.0, 3.0], \"name\": \"image-embeddings\" } }
 * @export
 * @interface NamedVectorStruct
 */
export interface NamedVectorStruct {
    /**
     * Name of vector data
     * @type {string}
     * @memberof NamedVectorStruct
     */
    'name': string;
    /**
     * Vector data
     * @type {Array<number>}
     * @memberof NamedVectorStruct
     */
    'vector': Array<number>;
}
/**
 * Select points with payload for a specified nested field
 * @export
 * @interface Nested
 */
export interface Nested {
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    'key': string;
    /**
     * 
     * @type {Filter}
     * @memberof Nested
     */
    'filter': Filter;
}
/**
 * 
 * @export
 * @interface NestedCondition
 */
export interface NestedCondition {
    /**
     * 
     * @type {Nested}
     * @memberof NestedCondition
     */
    'nested': Nested;
}
/**
 * 
 * @export
 * @interface OperationDurationStatistics
 */
export interface OperationDurationStatistics {
    /**
     * 
     * @type {number}
     * @memberof OperationDurationStatistics
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof OperationDurationStatistics
     */
    'fail_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof OperationDurationStatistics
     */
    'avg_duration_micros'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OperationDurationStatistics
     */
    'min_duration_micros'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OperationDurationStatistics
     */
    'max_duration_micros'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OperationDurationStatistics
     */
    'last_responded'?: string | null;
}
/**
 * 
 * @export
 * @interface OptimizerTelemetry
 */
export interface OptimizerTelemetry {
    /**
     * 
     * @type {OptimizersStatus}
     * @memberof OptimizerTelemetry
     */
    'status': OptimizersStatus;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof OptimizerTelemetry
     */
    'optimizations': OperationDurationStatistics;
}
/**
 * 
 * @export
 * @interface OptimizersConfig
 */
export interface OptimizersConfig {
    /**
     * The minimal fraction of deleted vectors in a segment, required to perform segment optimization
     * @type {number}
     * @memberof OptimizersConfig
     */
    'deleted_threshold': number;
    /**
     * The minimal number of vectors in a segment, required to perform segment optimization
     * @type {number}
     * @memberof OptimizersConfig
     */
    'vacuum_min_vector_number': number;
    /**
     * Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS  It is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads. If `default_segment_number = 0`, will be automatically selected by the number of available CPUs.
     * @type {number}
     * @memberof OptimizersConfig
     */
    'default_segment_number': number;
    /**
     * Do not create segments larger this size (in kilobytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.  If indexing speed is more important - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256 If not set, will be automatically selected considering the number of available CPUs.
     * @type {number}
     * @memberof OptimizersConfig
     */
    'max_segment_size'?: number | null;
    /**
     * Maximum size (in kilobytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.  Memmap storage is disabled by default, to enable it, set this threshold to a reasonable value.  To disable memmap storage, set this to `0`. Internally it will use the largest threshold possible.  Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof OptimizersConfig
     */
    'memmap_threshold'?: number | null;
    /**
     * Maximum size (in kilobytes) of vectors allowed for plain index, exceeding this threshold will enable vector indexing  Default value is 20,000, based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md>.  To disable vector indexing, set to `0`.  Note: 1kB = 1 vector of size 256.
     * @type {number}
     * @memberof OptimizersConfig
     */
    'indexing_threshold'?: number | null;
    /**
     * Minimum interval between forced flushes.
     * @type {number}
     * @memberof OptimizersConfig
     */
    'flush_interval_sec': number;
    /**
     * Maximum available threads for optimization workers
     * @type {number}
     * @memberof OptimizersConfig
     */
    'max_optimization_threads': number;
}
/**
 * 
 * @export
 * @interface OptimizersConfigDiff
 */
export interface OptimizersConfigDiff {
    /**
     * The minimal fraction of deleted vectors in a segment, required to perform segment optimization
     * @type {number}
     * @memberof OptimizersConfigDiff
     */
    'deleted_threshold'?: number | null;
    /**
     * The minimal number of vectors in a segment, required to perform segment optimization
     * @type {number}
     * @memberof OptimizersConfigDiff
     */
    'vacuum_min_vector_number'?: number | null;
    /**
     * Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS  It is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads If `default_segment_number = 0`, will be automatically selected by the number of available CPUs
     * @type {number}
     * @memberof OptimizersConfigDiff
     */
    'default_segment_number'?: number | null;
    /**
     * Do not create segments larger this size (in kilobytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.  If indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof OptimizersConfigDiff
     */
    'max_segment_size'?: number | null;
    /**
     * Maximum size (in kilobytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.  Memmap storage is disabled by default, to enable it, set this threshold to a reasonable value.  To disable memmap storage, set this to `0`.  Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof OptimizersConfigDiff
     */
    'memmap_threshold'?: number | null;
    /**
     * Maximum size (in kilobytes) of vectors allowed for plain index, exceeding this threshold will enable vector indexing  Default value is 20,000, based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md>.  To disable vector indexing, set to `0`.  Note: 1kB = 1 vector of size 256.
     * @type {number}
     * @memberof OptimizersConfigDiff
     */
    'indexing_threshold'?: number | null;
    /**
     * Minimum interval between forced flushes.
     * @type {number}
     * @memberof OptimizersConfigDiff
     */
    'flush_interval_sec'?: number | null;
    /**
     * Maximum available threads for optimization workers
     * @type {number}
     * @memberof OptimizersConfigDiff
     */
    'max_optimization_threads'?: number | null;
}
/**
 * @type OptimizersStatus
 * Current state of the collection
 * @export
 */
export type OptimizersStatus = OptimizersStatusOneOf | string;

/**
 * Something wrong happened with optimizers
 * @export
 * @interface OptimizersStatusOneOf
 */
export interface OptimizersStatusOneOf {
    /**
     * 
     * @type {string}
     * @memberof OptimizersStatusOneOf
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface P2pConfigTelemetry
 */
export interface P2pConfigTelemetry {
    /**
     * 
     * @type {number}
     * @memberof P2pConfigTelemetry
     */
    'connection_pool_size': number;
}
/**
 * Payload field
 * @export
 * @interface PayloadField
 */
export interface PayloadField {
    /**
     * Payload field name
     * @type {string}
     * @memberof PayloadField
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface PayloadFieldSchema
 */
export interface PayloadFieldSchema {
    /**
     * 
     * @type {TextIndexType}
     * @memberof PayloadFieldSchema
     */
    'type': TextIndexType;
    /**
     * 
     * @type {TokenizerType}
     * @memberof PayloadFieldSchema
     */
    'tokenizer'?: TokenizerType;
    /**
     * 
     * @type {number}
     * @memberof PayloadFieldSchema
     */
    'min_token_len'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayloadFieldSchema
     */
    'max_token_len'?: number | null;
    /**
     * If true, lowercase all tokens. Default: true
     * @type {boolean}
     * @memberof PayloadFieldSchema
     */
    'lowercase'?: boolean | null;
}


/**
 * Display payload field type & index information
 * @export
 * @interface PayloadIndexInfo
 */
export interface PayloadIndexInfo {
    /**
     * 
     * @type {PayloadSchemaType}
     * @memberof PayloadIndexInfo
     */
    'data_type': PayloadSchemaType;
    /**
     * 
     * @type {PayloadIndexInfoParams}
     * @memberof PayloadIndexInfo
     */
    'params'?: PayloadIndexInfoParams;
    /**
     * Number of points indexed with this index
     * @type {number}
     * @memberof PayloadIndexInfo
     */
    'points': number;
}


/**
 * 
 * @export
 * @interface PayloadIndexInfoParams
 */
export interface PayloadIndexInfoParams {
    /**
     * 
     * @type {TextIndexType}
     * @memberof PayloadIndexInfoParams
     */
    'type': TextIndexType;
    /**
     * 
     * @type {TokenizerType}
     * @memberof PayloadIndexInfoParams
     */
    'tokenizer'?: TokenizerType;
    /**
     * 
     * @type {number}
     * @memberof PayloadIndexInfoParams
     */
    'min_token_len'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayloadIndexInfoParams
     */
    'max_token_len'?: number | null;
    /**
     * If true, lowercase all tokens. Default: true
     * @type {boolean}
     * @memberof PayloadIndexInfoParams
     */
    'lowercase'?: boolean | null;
}


/**
 * 
 * @export
 * @interface PayloadIndexTelemetry
 */
export interface PayloadIndexTelemetry {
    /**
     * 
     * @type {string}
     * @memberof PayloadIndexTelemetry
     */
    'field_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PayloadIndexTelemetry
     */
    'points_values_count': number;
    /**
     * 
     * @type {number}
     * @memberof PayloadIndexTelemetry
     */
    'points_count': number;
    /**
     * 
     * @type {number}
     * @memberof PayloadIndexTelemetry
     */
    'histogram_bucket_size'?: number | null;
}
/**
 * Payload type with parameters
 * @export
 * @interface PayloadSchemaParams
 */
export interface PayloadSchemaParams {
    /**
     * 
     * @type {TextIndexType}
     * @memberof PayloadSchemaParams
     */
    'type': TextIndexType;
    /**
     * 
     * @type {TokenizerType}
     * @memberof PayloadSchemaParams
     */
    'tokenizer'?: TokenizerType;
    /**
     * 
     * @type {number}
     * @memberof PayloadSchemaParams
     */
    'min_token_len'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayloadSchemaParams
     */
    'max_token_len'?: number | null;
    /**
     * If true, lowercase all tokens. Default: true
     * @type {boolean}
     * @memberof PayloadSchemaParams
     */
    'lowercase'?: boolean | null;
}


/**
 * All possible names of payload types
 * @export
 * @enum {string}
 */

export const PayloadSchemaType = {
    Keyword: 'keyword',
    Integer: 'integer',
    Float: 'float',
    Geo: 'geo',
    Text: 'text'
} as const;

export type PayloadSchemaType = typeof PayloadSchemaType[keyof typeof PayloadSchemaType];


/**
 * Specifies how to treat payload selector
 * @export
 * @interface PayloadSelector
 */
export interface PayloadSelector {
    /**
     * Only include this payload keys
     * @type {Array<string>}
     * @memberof PayloadSelector
     */
    'include': Array<string>;
    /**
     * Exclude this fields from returning payload
     * @type {Array<string>}
     * @memberof PayloadSelector
     */
    'exclude': Array<string>;
}
/**
 * 
 * @export
 * @interface PayloadSelectorExclude
 */
export interface PayloadSelectorExclude {
    /**
     * Exclude this fields from returning payload
     * @type {Array<string>}
     * @memberof PayloadSelectorExclude
     */
    'exclude': Array<string>;
}
/**
 * 
 * @export
 * @interface PayloadSelectorInclude
 */
export interface PayloadSelectorInclude {
    /**
     * Only include this payload keys
     * @type {Array<string>}
     * @memberof PayloadSelectorInclude
     */
    'include': Array<string>;
}
/**
 * @type PayloadStorageType
 * Type of payload storage
 * @export
 */
export type PayloadStorageType = PayloadStorageTypeOneOf | PayloadStorageTypeOneOf1;

/**
 * 
 * @export
 * @interface PayloadStorageTypeOneOf
 */
export interface PayloadStorageTypeOneOf {
    /**
     * 
     * @type {string}
     * @memberof PayloadStorageTypeOneOf
     */
    'type': PayloadStorageTypeOneOfTypeEnum;
}

export const PayloadStorageTypeOneOfTypeEnum = {
    InMemory: 'in_memory'
} as const;

export type PayloadStorageTypeOneOfTypeEnum = typeof PayloadStorageTypeOneOfTypeEnum[keyof typeof PayloadStorageTypeOneOfTypeEnum];

/**
 * 
 * @export
 * @interface PayloadStorageTypeOneOf1
 */
export interface PayloadStorageTypeOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof PayloadStorageTypeOneOf1
     */
    'type': PayloadStorageTypeOneOf1TypeEnum;
}

export const PayloadStorageTypeOneOf1TypeEnum = {
    OnDisk: 'on_disk'
} as const;

export type PayloadStorageTypeOneOf1TypeEnum = typeof PayloadStorageTypeOneOf1TypeEnum[keyof typeof PayloadStorageTypeOneOf1TypeEnum];

/**
 * Information of a peer in the cluster
 * @export
 * @interface PeerInfo
 */
export interface PeerInfo {
    /**
     * 
     * @type {string}
     * @memberof PeerInfo
     */
    'uri': string;
}
/**
 * 
 * @export
 * @interface PointGroup
 */
export interface PointGroup {
    /**
     * Scored points that have the same value of the group_by key
     * @type {Array<ScoredPoint>}
     * @memberof PointGroup
     */
    'hits': Array<ScoredPoint>;
    /**
     * 
     * @type {GroupId}
     * @memberof PointGroup
     */
    'id': GroupId;
}
/**
 * 
 * @export
 * @interface PointIdsList
 */
export interface PointIdsList {
    /**
     * 
     * @type {Array<ExtendedPointId>}
     * @memberof PointIdsList
     */
    'points': Array<ExtendedPointId>;
}
/**
 * @type PointInsertOperations
 * @export
 */
export type PointInsertOperations = PointsBatch | PointsList;

/**
 * 
 * @export
 * @interface PointRequest
 */
export interface PointRequest {
    /**
     * Look for points with ids
     * @type {Array<ExtendedPointId>}
     * @memberof PointRequest
     */
    'ids': Array<ExtendedPointId>;
    /**
     * 
     * @type {PointRequestWithPayload}
     * @memberof PointRequest
     */
    'with_payload'?: PointRequestWithPayload;
    /**
     * 
     * @type {WithVector}
     * @memberof PointRequest
     */
    'with_vector'?: WithVector;
}
/**
 * Select which payload to return with the response. Default: All
 * @export
 * @interface PointRequestWithPayload
 */
export interface PointRequestWithPayload {
    /**
     * Only include this payload keys
     * @type {Array<string>}
     * @memberof PointRequestWithPayload
     */
    'include': Array<string>;
    /**
     * Exclude this fields from returning payload
     * @type {Array<string>}
     * @memberof PointRequestWithPayload
     */
    'exclude': Array<string>;
}
/**
 * 
 * @export
 * @interface PointStruct
 */
export interface PointStruct {
    /**
     * 
     * @type {ExtendedPointId}
     * @memberof PointStruct
     */
    'id': ExtendedPointId;
    /**
     * 
     * @type {VectorStruct}
     * @memberof PointStruct
     */
    'vector': VectorStruct;
    /**
     * 
     * @type {PointStructPayload}
     * @memberof PointStruct
     */
    'payload'?: PointStructPayload;
}
/**
 * Payload values (optional)
 * @export
 * @interface PointStructPayload
 */
export interface PointStructPayload {
}
/**
 * 
 * @export
 * @interface PointVectors
 */
export interface PointVectors {
    /**
     * 
     * @type {ExtendedPointId}
     * @memberof PointVectors
     */
    'id': ExtendedPointId;
    /**
     * 
     * @type {VectorStruct}
     * @memberof PointVectors
     */
    'vector': VectorStruct;
}
/**
 * 
 * @export
 * @interface PointsBatch
 */
export interface PointsBatch {
    /**
     * 
     * @type {Batch}
     * @memberof PointsBatch
     */
    'batch': Batch;
}
/**
 * 
 * @export
 * @interface PointsList
 */
export interface PointsList {
    /**
     * 
     * @type {Array<PointStruct>}
     * @memberof PointsList
     */
    'points': Array<PointStruct>;
}
/**
 * 
 * @export
 * @interface PointsSelector
 */
export interface PointsSelector {
    /**
     * 
     * @type {Array<ExtendedPointId>}
     * @memberof PointsSelector
     */
    'points': Array<ExtendedPointId>;
    /**
     * 
     * @type {Filter}
     * @memberof PointsSelector
     */
    'filter': Filter;
}
/**
 * 
 * @export
 * @interface ProductQuantization
 */
export interface ProductQuantization {
    /**
     * 
     * @type {ProductQuantizationConfig}
     * @memberof ProductQuantization
     */
    'product': ProductQuantizationConfig;
}
/**
 * 
 * @export
 * @interface ProductQuantizationConfig
 */
export interface ProductQuantizationConfig {
    /**
     * 
     * @type {CompressionRatio}
     * @memberof ProductQuantizationConfig
     */
    'compression': CompressionRatio;
    /**
     * 
     * @type {boolean}
     * @memberof ProductQuantizationConfig
     */
    'always_ram'?: boolean | null;
}


/**
 * 
 * @export
 * @interface QuantizationConfig
 */
export interface QuantizationConfig {
    /**
     * 
     * @type {ScalarQuantizationConfig}
     * @memberof QuantizationConfig
     */
    'scalar': ScalarQuantizationConfig;
    /**
     * 
     * @type {ProductQuantizationConfig}
     * @memberof QuantizationConfig
     */
    'product': ProductQuantizationConfig;
}
/**
 * Additional parameters of the search
 * @export
 * @interface QuantizationSearchParams
 */
export interface QuantizationSearchParams {
    /**
     * If true, quantized vectors are ignored. Default is false.
     * @type {boolean}
     * @memberof QuantizationSearchParams
     */
    'ignore'?: boolean;
    /**
     * If true, use original vectors to re-score top-k results. Might require more time in case if original vectors are stored on disk. Default is false.
     * @type {boolean}
     * @memberof QuantizationSearchParams
     */
    'rescore'?: boolean;
}
/**
 * Summary information about the current raft state
 * @export
 * @interface RaftInfo
 */
export interface RaftInfo {
    /**
     * Raft divides time into terms of arbitrary length, each beginning with an election. If a candidate wins the election, it remains the leader for the rest of the term. The term number increases monotonically. Each server stores the current term number which is also exchanged in every communication.
     * @type {number}
     * @memberof RaftInfo
     */
    'term': number;
    /**
     * The index of the latest committed (finalized) operation that this peer is aware of.
     * @type {number}
     * @memberof RaftInfo
     */
    'commit': number;
    /**
     * Number of consensus operations pending to be applied on this peer
     * @type {number}
     * @memberof RaftInfo
     */
    'pending_operations': number;
    /**
     * Leader of the current term
     * @type {number}
     * @memberof RaftInfo
     */
    'leader'?: number | null;
    /**
     * 
     * @type {RaftInfoRole}
     * @memberof RaftInfo
     */
    'role'?: RaftInfoRole;
    /**
     * Is this peer a voter or a learner
     * @type {boolean}
     * @memberof RaftInfo
     */
    'is_voter': boolean;
}
/**
 * Role of this peer in the current term
 * @export
 * @interface RaftInfoRole
 */
export interface RaftInfoRole {
}
/**
 * Range filter request
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * point.key < range.lt
     * @type {number}
     * @memberof Range
     */
    'lt'?: number | null;
    /**
     * point.key > range.gt
     * @type {number}
     * @memberof Range
     */
    'gt'?: number | null;
    /**
     * point.key >= range.gte
     * @type {number}
     * @memberof Range
     */
    'gte'?: number | null;
    /**
     * point.key <= range.lte
     * @type {number}
     * @memberof Range
     */
    'lte'?: number | null;
}
/**
 * Read consistency parameter  Defines how many replicas should be queried to get the result  * `N` - send N random request and return points, which present on all of them  * `majority` - send N/2+1 random request and return points, which present on all of them  * `quorum` - send requests to all nodes and return points which present on majority of them  * `all` - send requests to all nodes and return points which present on all of them  Default value is `Factor(1)`
 * @export
 * @interface ReadConsistency
 */
export interface ReadConsistency {
}
/**
 * * `majority` - send N/2+1 random request and return points, which present on all of them  * `quorum` - send requests to all nodes and return points which present on majority of nodes  * `all` - send requests to all nodes and return points which present on all nodes
 * @export
 * @enum {string}
 */

export const ReadConsistencyType = {
    Majority: 'majority',
    Quorum: 'quorum',
    All: 'all'
} as const;

export type ReadConsistencyType = typeof ReadConsistencyType[keyof typeof ReadConsistencyType];


/**
 * 
 * @export
 * @interface RecommendGroupsRequest
 */
export interface RecommendGroupsRequest {
    /**
     * Look for vectors closest to those
     * @type {Array<ExtendedPointId>}
     * @memberof RecommendGroupsRequest
     */
    'positive': Array<ExtendedPointId>;
    /**
     * Try to avoid vectors like this
     * @type {Array<ExtendedPointId>}
     * @memberof RecommendGroupsRequest
     */
    'negative'?: Array<ExtendedPointId>;
    /**
     * 
     * @type {SearchRequestFilter}
     * @memberof RecommendGroupsRequest
     */
    'filter'?: SearchRequestFilter;
    /**
     * 
     * @type {SearchRequestParams}
     * @memberof RecommendGroupsRequest
     */
    'params'?: SearchRequestParams;
    /**
     * 
     * @type {SearchRequestWithPayload}
     * @memberof RecommendGroupsRequest
     */
    'with_payload'?: SearchRequestWithPayload;
    /**
     * 
     * @type {SearchRequestWithVector}
     * @memberof RecommendGroupsRequest
     */
    'with_vector'?: SearchRequestWithVector;
    /**
     * Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
     * @type {number}
     * @memberof RecommendGroupsRequest
     */
    'score_threshold'?: number | null;
    /**
     * 
     * @type {RecommendRequestUsing}
     * @memberof RecommendGroupsRequest
     */
    'using'?: RecommendRequestUsing;
    /**
     * 
     * @type {RecommendRequestLookupFrom}
     * @memberof RecommendGroupsRequest
     */
    'lookup_from'?: RecommendRequestLookupFrom;
    /**
     * Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups.
     * @type {string}
     * @memberof RecommendGroupsRequest
     */
    'group_by': string;
    /**
     * Maximum amount of points to return per group
     * @type {number}
     * @memberof RecommendGroupsRequest
     */
    'group_size': number;
    /**
     * Maximum amount of groups to return
     * @type {number}
     * @memberof RecommendGroupsRequest
     */
    'limit': number;
}
/**
 * Recommendation request. Provides positive and negative examples of the vectors, which are already stored in the collection.  Service should look for the points which are closer to positive examples and at the same time further to negative examples. The concrete way of how to compare negative and positive distances is up to implementation in `segment` crate.
 * @export
 * @interface RecommendRequest
 */
export interface RecommendRequest {
    /**
     * Look for vectors closest to those
     * @type {Array<ExtendedPointId>}
     * @memberof RecommendRequest
     */
    'positive': Array<ExtendedPointId>;
    /**
     * Try to avoid vectors like this
     * @type {Array<ExtendedPointId>}
     * @memberof RecommendRequest
     */
    'negative'?: Array<ExtendedPointId>;
    /**
     * 
     * @type {SearchRequestFilter}
     * @memberof RecommendRequest
     */
    'filter'?: SearchRequestFilter;
    /**
     * 
     * @type {SearchRequestParams}
     * @memberof RecommendRequest
     */
    'params'?: SearchRequestParams;
    /**
     * Max number of result to return
     * @type {number}
     * @memberof RecommendRequest
     */
    'limit': number;
    /**
     * Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues.
     * @type {number}
     * @memberof RecommendRequest
     */
    'offset'?: number;
    /**
     * 
     * @type {SearchRequestWithPayload}
     * @memberof RecommendRequest
     */
    'with_payload'?: SearchRequestWithPayload;
    /**
     * 
     * @type {SearchRequestWithVector}
     * @memberof RecommendRequest
     */
    'with_vector'?: SearchRequestWithVector;
    /**
     * Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
     * @type {number}
     * @memberof RecommendRequest
     */
    'score_threshold'?: number | null;
    /**
     * 
     * @type {RecommendRequestUsing}
     * @memberof RecommendRequest
     */
    'using'?: RecommendRequestUsing;
    /**
     * 
     * @type {RecommendRequestLookupFrom}
     * @memberof RecommendRequest
     */
    'lookup_from'?: RecommendRequestLookupFrom;
}
/**
 * 
 * @export
 * @interface RecommendRequestBatch
 */
export interface RecommendRequestBatch {
    /**
     * 
     * @type {Array<RecommendRequest>}
     * @memberof RecommendRequestBatch
     */
    'searches': Array<RecommendRequest>;
}
/**
 * The location used to lookup vectors. If not specified - use current collection. Note: the other collection should have the same vector size as the current collection
 * @export
 * @interface RecommendRequestLookupFrom
 */
export interface RecommendRequestLookupFrom {
    /**
     * Name of the collection used for lookup
     * @type {string}
     * @memberof RecommendRequestLookupFrom
     */
    'collection': string;
    /**
     * Optional name of the vector field within the collection. If not provided, the default vector field will be used.
     * @type {string}
     * @memberof RecommendRequestLookupFrom
     */
    'vector'?: string | null;
}
/**
 * Define which vector to use for recommendation, if not specified - try to use default vector
 * @export
 * @interface RecommendRequestUsing
 */
export interface RecommendRequestUsing {
}
/**
 * Point data
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * 
     * @type {ExtendedPointId}
     * @memberof Record
     */
    'id': ExtendedPointId;
    /**
     * 
     * @type {RecordPayload}
     * @memberof Record
     */
    'payload'?: RecordPayload;
    /**
     * 
     * @type {RecordVector}
     * @memberof Record
     */
    'vector'?: RecordVector;
}
/**
 * Payload - values assigned to the point
 * @export
 * @interface RecordPayload
 */
export interface RecordPayload {
}
/**
 * Vector of the point
 * @export
 * @interface RecordVector
 */
export interface RecordVector {
}
/**
 * 
 * @export
 * @interface RecoverCurrentPeer200Response
 */
export interface RecoverCurrentPeer200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof RecoverCurrentPeer200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof RecoverCurrentPeer200Response
     */
    'status'?: RecoverCurrentPeer200ResponseStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof RecoverCurrentPeer200Response
     */
    'result'?: boolean;
}

export const RecoverCurrentPeer200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type RecoverCurrentPeer200ResponseStatusEnum = typeof RecoverCurrentPeer200ResponseStatusEnum[keyof typeof RecoverCurrentPeer200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface RecoverFromUploadedSnapshot202Response
 */
export interface RecoverFromUploadedSnapshot202Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof RecoverFromUploadedSnapshot202Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof RecoverFromUploadedSnapshot202Response
     */
    'status'?: RecoverFromUploadedSnapshot202ResponseStatusEnum;
}

export const RecoverFromUploadedSnapshot202ResponseStatusEnum = {
    Accepted: 'accepted'
} as const;

export type RecoverFromUploadedSnapshot202ResponseStatusEnum = typeof RecoverFromUploadedSnapshot202ResponseStatusEnum[keyof typeof RecoverFromUploadedSnapshot202ResponseStatusEnum];

/**
 * 
 * @export
 * @interface RemoteShardInfo
 */
export interface RemoteShardInfo {
    /**
     * Remote shard id
     * @type {number}
     * @memberof RemoteShardInfo
     */
    'shard_id': number;
    /**
     * Remote peer id
     * @type {number}
     * @memberof RemoteShardInfo
     */
    'peer_id': number;
    /**
     * 
     * @type {ReplicaState}
     * @memberof RemoteShardInfo
     */
    'state': ReplicaState;
}


/**
 * 
 * @export
 * @interface RemoteShardTelemetry
 */
export interface RemoteShardTelemetry {
    /**
     * 
     * @type {number}
     * @memberof RemoteShardTelemetry
     */
    'shard_id': number;
    /**
     * 
     * @type {number}
     * @memberof RemoteShardTelemetry
     */
    'peer_id'?: number | null;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof RemoteShardTelemetry
     */
    'searches': OperationDurationStatistics;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof RemoteShardTelemetry
     */
    'updates': OperationDurationStatistics;
}
/**
 * Change alias to a new one
 * @export
 * @interface RenameAlias
 */
export interface RenameAlias {
    /**
     * 
     * @type {string}
     * @memberof RenameAlias
     */
    'old_alias_name': string;
    /**
     * 
     * @type {string}
     * @memberof RenameAlias
     */
    'new_alias_name': string;
}
/**
 * Change alias to a new one
 * @export
 * @interface RenameAliasOperation
 */
export interface RenameAliasOperation {
    /**
     * 
     * @type {RenameAlias}
     * @memberof RenameAliasOperation
     */
    'rename_alias': RenameAlias;
}
/**
 * 
 * @export
 * @interface Replica
 */
export interface Replica {
    /**
     * 
     * @type {number}
     * @memberof Replica
     */
    'shard_id': number;
    /**
     * 
     * @type {number}
     * @memberof Replica
     */
    'peer_id': number;
}
/**
 * 
 * @export
 * @interface ReplicaSetTelemetry
 */
export interface ReplicaSetTelemetry {
    /**
     * 
     * @type {number}
     * @memberof ReplicaSetTelemetry
     */
    'id': number;
    /**
     * 
     * @type {ReplicaSetTelemetryLocal}
     * @memberof ReplicaSetTelemetry
     */
    'local'?: ReplicaSetTelemetryLocal;
    /**
     * 
     * @type {Array<RemoteShardTelemetry>}
     * @memberof ReplicaSetTelemetry
     */
    'remote': Array<RemoteShardTelemetry>;
    /**
     * 
     * @type {{ [key: string]: ReplicaState; }}
     * @memberof ReplicaSetTelemetry
     */
    'replicate_states': { [key: string]: ReplicaState; };
}
/**
 * 
 * @export
 * @interface ReplicaSetTelemetryLocal
 */
export interface ReplicaSetTelemetryLocal {
    /**
     * 
     * @type {string}
     * @memberof ReplicaSetTelemetryLocal
     */
    'variant_name'?: string | null;
    /**
     * 
     * @type {Array<SegmentTelemetry>}
     * @memberof ReplicaSetTelemetryLocal
     */
    'segments': Array<SegmentTelemetry>;
    /**
     * 
     * @type {OptimizerTelemetry}
     * @memberof ReplicaSetTelemetryLocal
     */
    'optimizations': OptimizerTelemetry;
}
/**
 * State of the single shard within a replica set.
 * @export
 * @enum {string}
 */

export const ReplicaState = {
    Active: 'Active',
    Dead: 'Dead',
    Partial: 'Partial',
    Initializing: 'Initializing',
    Listener: 'Listener'
} as const;

export type ReplicaState = typeof ReplicaState[keyof typeof ReplicaState];


/**
 * 
 * @export
 * @interface ReplicateShardOperation
 */
export interface ReplicateShardOperation {
    /**
     * 
     * @type {MoveShard}
     * @memberof ReplicateShardOperation
     */
    'replicate_shard': MoveShard;
}
/**
 * 
 * @export
 * @interface RequestsTelemetry
 */
export interface RequestsTelemetry {
    /**
     * 
     * @type {WebApiTelemetry}
     * @memberof RequestsTelemetry
     */
    'rest': WebApiTelemetry;
    /**
     * 
     * @type {GrpcTelemetry}
     * @memberof RequestsTelemetry
     */
    'grpc': GrpcTelemetry;
}
/**
 * 
 * @export
 * @interface RunningEnvironmentTelemetry
 */
export interface RunningEnvironmentTelemetry {
    /**
     * 
     * @type {string}
     * @memberof RunningEnvironmentTelemetry
     */
    'distribution'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RunningEnvironmentTelemetry
     */
    'distribution_version'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RunningEnvironmentTelemetry
     */
    'is_docker': boolean;
    /**
     * 
     * @type {number}
     * @memberof RunningEnvironmentTelemetry
     */
    'cores'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RunningEnvironmentTelemetry
     */
    'ram_size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RunningEnvironmentTelemetry
     */
    'disk_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RunningEnvironmentTelemetry
     */
    'cpu_flags': string;
}
/**
 * 
 * @export
 * @interface ScalarQuantization
 */
export interface ScalarQuantization {
    /**
     * 
     * @type {ScalarQuantizationConfig}
     * @memberof ScalarQuantization
     */
    'scalar': ScalarQuantizationConfig;
}
/**
 * 
 * @export
 * @interface ScalarQuantizationConfig
 */
export interface ScalarQuantizationConfig {
    /**
     * 
     * @type {ScalarType}
     * @memberof ScalarQuantizationConfig
     */
    'type': ScalarType;
    /**
     * Quantile for quantization. Expected value range in [0.5, 1.0]. If not set - use the whole range of values
     * @type {number}
     * @memberof ScalarQuantizationConfig
     */
    'quantile'?: number | null;
    /**
     * If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
     * @type {boolean}
     * @memberof ScalarQuantizationConfig
     */
    'always_ram'?: boolean | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ScalarType = {
    Int8: 'int8'
} as const;

export type ScalarType = typeof ScalarType[keyof typeof ScalarType];


/**
 * Search result
 * @export
 * @interface ScoredPoint
 */
export interface ScoredPoint {
    /**
     * 
     * @type {ExtendedPointId}
     * @memberof ScoredPoint
     */
    'id': ExtendedPointId;
    /**
     * Point version
     * @type {number}
     * @memberof ScoredPoint
     */
    'version': number;
    /**
     * Points vector distance to the query vector
     * @type {number}
     * @memberof ScoredPoint
     */
    'score': number;
    /**
     * 
     * @type {RecordPayload}
     * @memberof ScoredPoint
     */
    'payload'?: RecordPayload;
    /**
     * 
     * @type {RecordVector}
     * @memberof ScoredPoint
     */
    'vector'?: RecordVector;
}
/**
 * 
 * @export
 * @interface ScrollPoints200Response
 */
export interface ScrollPoints200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof ScrollPoints200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScrollPoints200Response
     */
    'status'?: ScrollPoints200ResponseStatusEnum;
    /**
     * 
     * @type {ScrollResult}
     * @memberof ScrollPoints200Response
     */
    'result'?: ScrollResult;
}

export const ScrollPoints200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type ScrollPoints200ResponseStatusEnum = typeof ScrollPoints200ResponseStatusEnum[keyof typeof ScrollPoints200ResponseStatusEnum];

/**
 * Scroll request - paginate over all points which matches given condition
 * @export
 * @interface ScrollRequest
 */
export interface ScrollRequest {
    /**
     * 
     * @type {ScrollRequestOffset}
     * @memberof ScrollRequest
     */
    'offset'?: ScrollRequestOffset;
    /**
     * Page size. Default: 10
     * @type {number}
     * @memberof ScrollRequest
     */
    'limit'?: number | null;
    /**
     * 
     * @type {ScrollRequestFilter}
     * @memberof ScrollRequest
     */
    'filter'?: ScrollRequestFilter;
    /**
     * 
     * @type {PointRequestWithPayload}
     * @memberof ScrollRequest
     */
    'with_payload'?: PointRequestWithPayload;
    /**
     * 
     * @type {WithVector}
     * @memberof ScrollRequest
     */
    'with_vector'?: WithVector;
}
/**
 * Look only for points which satisfies this conditions. If not provided - all points.
 * @export
 * @interface ScrollRequestFilter
 */
export interface ScrollRequestFilter {
    /**
     * At least one of those conditions should match
     * @type {Array<Condition>}
     * @memberof ScrollRequestFilter
     */
    'should'?: Array<Condition> | null;
    /**
     * All conditions must match
     * @type {Array<Condition>}
     * @memberof ScrollRequestFilter
     */
    'must'?: Array<Condition> | null;
    /**
     * All conditions must NOT match
     * @type {Array<Condition>}
     * @memberof ScrollRequestFilter
     */
    'must_not'?: Array<Condition> | null;
}
/**
 * Start ID to read points from.
 * @export
 * @interface ScrollRequestOffset
 */
export interface ScrollRequestOffset {
}
/**
 * Result of the points read request
 * @export
 * @interface ScrollResult
 */
export interface ScrollResult {
    /**
     * List of retrieved points
     * @type {Array<Record>}
     * @memberof ScrollResult
     */
    'points': Array<Record>;
    /**
     * 
     * @type {ScrollResultNextPageOffset}
     * @memberof ScrollResult
     */
    'next_page_offset'?: ScrollResultNextPageOffset;
}
/**
 * Offset which should be used to retrieve a next page result
 * @export
 * @interface ScrollResultNextPageOffset
 */
export interface ScrollResultNextPageOffset {
}
/**
 * 
 * @export
 * @interface SearchBatchPoints200Response
 */
export interface SearchBatchPoints200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof SearchBatchPoints200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchBatchPoints200Response
     */
    'status'?: SearchBatchPoints200ResponseStatusEnum;
    /**
     * 
     * @type {Array<Array<ScoredPoint>>}
     * @memberof SearchBatchPoints200Response
     */
    'result'?: Array<Array<ScoredPoint>>;
}

export const SearchBatchPoints200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type SearchBatchPoints200ResponseStatusEnum = typeof SearchBatchPoints200ResponseStatusEnum[keyof typeof SearchBatchPoints200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface SearchGroupsRequest
 */
export interface SearchGroupsRequest {
    /**
     * 
     * @type {NamedVectorStruct}
     * @memberof SearchGroupsRequest
     */
    'vector': NamedVectorStruct;
    /**
     * 
     * @type {SearchRequestFilter}
     * @memberof SearchGroupsRequest
     */
    'filter'?: SearchRequestFilter;
    /**
     * 
     * @type {SearchRequestParams}
     * @memberof SearchGroupsRequest
     */
    'params'?: SearchRequestParams;
    /**
     * 
     * @type {SearchRequestWithPayload}
     * @memberof SearchGroupsRequest
     */
    'with_payload'?: SearchRequestWithPayload;
    /**
     * 
     * @type {SearchRequestWithVector}
     * @memberof SearchGroupsRequest
     */
    'with_vector'?: SearchRequestWithVector;
    /**
     * Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
     * @type {number}
     * @memberof SearchGroupsRequest
     */
    'score_threshold'?: number | null;
    /**
     * Payload field to group by, must be a string or number field. If the field contains more than 1 value, all values will be used for grouping. One point can be in multiple groups.
     * @type {string}
     * @memberof SearchGroupsRequest
     */
    'group_by': string;
    /**
     * Maximum amount of points to return per group
     * @type {number}
     * @memberof SearchGroupsRequest
     */
    'group_size': number;
    /**
     * Maximum amount of groups to return
     * @type {number}
     * @memberof SearchGroupsRequest
     */
    'limit': number;
}
/**
 * Additional parameters of the search
 * @export
 * @interface SearchParams
 */
export interface SearchParams {
    /**
     * Params relevant to HNSW index /// Size of the beam in a beam-search. Larger the value - more accurate the result, more time required for search.
     * @type {number}
     * @memberof SearchParams
     */
    'hnsw_ef'?: number | null;
    /**
     * Search without approximation. If set to true, search may run long but with exact results.
     * @type {boolean}
     * @memberof SearchParams
     */
    'exact'?: boolean;
    /**
     * 
     * @type {SearchParamsQuantization}
     * @memberof SearchParams
     */
    'quantization'?: SearchParamsQuantization;
}
/**
 * Quantization params
 * @export
 * @interface SearchParamsQuantization
 */
export interface SearchParamsQuantization {
    /**
     * If true, quantized vectors are ignored. Default is false.
     * @type {boolean}
     * @memberof SearchParamsQuantization
     */
    'ignore'?: boolean;
    /**
     * If true, use original vectors to re-score top-k results. Might require more time in case if original vectors are stored on disk. Default is false.
     * @type {boolean}
     * @memberof SearchParamsQuantization
     */
    'rescore'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchPointGroups200Response
 */
export interface SearchPointGroups200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof SearchPointGroups200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchPointGroups200Response
     */
    'status'?: SearchPointGroups200ResponseStatusEnum;
    /**
     * 
     * @type {GroupsResult}
     * @memberof SearchPointGroups200Response
     */
    'result'?: GroupsResult;
}

export const SearchPointGroups200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type SearchPointGroups200ResponseStatusEnum = typeof SearchPointGroups200ResponseStatusEnum[keyof typeof SearchPointGroups200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface SearchPoints200Response
 */
export interface SearchPoints200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof SearchPoints200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchPoints200Response
     */
    'status'?: SearchPoints200ResponseStatusEnum;
    /**
     * 
     * @type {Array<ScoredPoint>}
     * @memberof SearchPoints200Response
     */
    'result'?: Array<ScoredPoint>;
}

export const SearchPoints200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type SearchPoints200ResponseStatusEnum = typeof SearchPoints200ResponseStatusEnum[keyof typeof SearchPoints200ResponseStatusEnum];

/**
 * Search request. Holds all conditions and parameters for the search of most similar points by vector similarity given the filtering restrictions.
 * @export
 * @interface SearchRequest
 */
export interface SearchRequest {
    /**
     * 
     * @type {NamedVectorStruct}
     * @memberof SearchRequest
     */
    'vector': NamedVectorStruct;
    /**
     * 
     * @type {SearchRequestFilter}
     * @memberof SearchRequest
     */
    'filter'?: SearchRequestFilter;
    /**
     * 
     * @type {SearchRequestParams}
     * @memberof SearchRequest
     */
    'params'?: SearchRequestParams;
    /**
     * Max number of result to return
     * @type {number}
     * @memberof SearchRequest
     */
    'limit': number;
    /**
     * Offset of the first result to return. May be used to paginate results. Note: large offset values may cause performance issues.
     * @type {number}
     * @memberof SearchRequest
     */
    'offset'?: number;
    /**
     * 
     * @type {SearchRequestWithPayload}
     * @memberof SearchRequest
     */
    'with_payload'?: SearchRequestWithPayload;
    /**
     * 
     * @type {SearchRequestWithVector}
     * @memberof SearchRequest
     */
    'with_vector'?: SearchRequestWithVector;
    /**
     * Define a minimal score threshold for the result. If defined, less similar results will not be returned. Score of the returned result might be higher or smaller than the threshold depending on the Distance function used. E.g. for cosine similarity only higher scores will be returned.
     * @type {number}
     * @memberof SearchRequest
     */
    'score_threshold'?: number | null;
}
/**
 * 
 * @export
 * @interface SearchRequestBatch
 */
export interface SearchRequestBatch {
    /**
     * 
     * @type {Array<SearchRequest>}
     * @memberof SearchRequestBatch
     */
    'searches': Array<SearchRequest>;
}
/**
 * Look only for points which satisfies this conditions
 * @export
 * @interface SearchRequestFilter
 */
export interface SearchRequestFilter {
    /**
     * At least one of those conditions should match
     * @type {Array<Condition>}
     * @memberof SearchRequestFilter
     */
    'should'?: Array<Condition> | null;
    /**
     * All conditions must match
     * @type {Array<Condition>}
     * @memberof SearchRequestFilter
     */
    'must'?: Array<Condition> | null;
    /**
     * All conditions must NOT match
     * @type {Array<Condition>}
     * @memberof SearchRequestFilter
     */
    'must_not'?: Array<Condition> | null;
}
/**
 * Additional search params
 * @export
 * @interface SearchRequestParams
 */
export interface SearchRequestParams {
    /**
     * Params relevant to HNSW index /// Size of the beam in a beam-search. Larger the value - more accurate the result, more time required for search.
     * @type {number}
     * @memberof SearchRequestParams
     */
    'hnsw_ef'?: number | null;
    /**
     * Search without approximation. If set to true, search may run long but with exact results.
     * @type {boolean}
     * @memberof SearchRequestParams
     */
    'exact'?: boolean;
    /**
     * 
     * @type {SearchParamsQuantization}
     * @memberof SearchRequestParams
     */
    'quantization'?: SearchParamsQuantization;
}
/**
 * Select which payload to return with the response. Default: None
 * @export
 * @interface SearchRequestWithPayload
 */
export interface SearchRequestWithPayload {
    /**
     * Only include this payload keys
     * @type {Array<string>}
     * @memberof SearchRequestWithPayload
     */
    'include': Array<string>;
    /**
     * Exclude this fields from returning payload
     * @type {Array<string>}
     * @memberof SearchRequestWithPayload
     */
    'exclude': Array<string>;
}
/**
 * Whether to return the point vector with the result?
 * @export
 * @interface SearchRequestWithVector
 */
export interface SearchRequestWithVector {
}
/**
 * 
 * @export
 * @interface SegmentConfig
 */
export interface SegmentConfig {
    /**
     * 
     * @type {{ [key: string]: VectorDataConfig; }}
     * @memberof SegmentConfig
     */
    'vector_data': { [key: string]: VectorDataConfig; };
    /**
     * 
     * @type {PayloadStorageType}
     * @memberof SegmentConfig
     */
    'payload_storage_type': PayloadStorageType;
}
/**
 * Aggregated information about segment
 * @export
 * @interface SegmentInfo
 */
export interface SegmentInfo {
    /**
     * 
     * @type {SegmentType}
     * @memberof SegmentInfo
     */
    'segment_type': SegmentType;
    /**
     * 
     * @type {number}
     * @memberof SegmentInfo
     */
    'num_vectors': number;
    /**
     * 
     * @type {number}
     * @memberof SegmentInfo
     */
    'num_points': number;
    /**
     * 
     * @type {number}
     * @memberof SegmentInfo
     */
    'num_deleted_vectors': number;
    /**
     * 
     * @type {number}
     * @memberof SegmentInfo
     */
    'ram_usage_bytes': number;
    /**
     * 
     * @type {number}
     * @memberof SegmentInfo
     */
    'disk_usage_bytes': number;
    /**
     * 
     * @type {boolean}
     * @memberof SegmentInfo
     */
    'is_appendable': boolean;
    /**
     * 
     * @type {{ [key: string]: PayloadIndexInfo; }}
     * @memberof SegmentInfo
     */
    'index_schema': { [key: string]: PayloadIndexInfo; };
}


/**
 * 
 * @export
 * @interface SegmentTelemetry
 */
export interface SegmentTelemetry {
    /**
     * 
     * @type {SegmentInfo}
     * @memberof SegmentTelemetry
     */
    'info': SegmentInfo;
    /**
     * 
     * @type {SegmentConfig}
     * @memberof SegmentTelemetry
     */
    'config': SegmentConfig;
    /**
     * 
     * @type {Array<VectorIndexSearchesTelemetry>}
     * @memberof SegmentTelemetry
     */
    'vector_index_searches': Array<VectorIndexSearchesTelemetry>;
    /**
     * 
     * @type {Array<PayloadIndexTelemetry>}
     * @memberof SegmentTelemetry
     */
    'payload_field_indices': Array<PayloadIndexTelemetry>;
}
/**
 * Type of segment
 * @export
 * @enum {string}
 */

export const SegmentType = {
    Plain: 'plain',
    Indexed: 'indexed',
    Special: 'special'
} as const;

export type SegmentType = typeof SegmentType[keyof typeof SegmentType];


/**
 * 
 * @export
 * @interface SetPayload
 */
export interface SetPayload {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SetPayload
     */
    'payload': { [key: string]: any; };
    /**
     * Assigns payload to each point in this list
     * @type {Array<ExtendedPointId>}
     * @memberof SetPayload
     */
    'points'?: Array<ExtendedPointId> | null;
    /**
     * 
     * @type {SetPayloadFilter}
     * @memberof SetPayload
     */
    'filter'?: SetPayloadFilter;
}
/**
 * Assigns payload to each point that satisfy this filter condition
 * @export
 * @interface SetPayloadFilter
 */
export interface SetPayloadFilter {
    /**
     * At least one of those conditions should match
     * @type {Array<Condition>}
     * @memberof SetPayloadFilter
     */
    'should'?: Array<Condition> | null;
    /**
     * All conditions must match
     * @type {Array<Condition>}
     * @memberof SetPayloadFilter
     */
    'must'?: Array<Condition> | null;
    /**
     * All conditions must NOT match
     * @type {Array<Condition>}
     * @memberof SetPayloadFilter
     */
    'must_not'?: Array<Condition> | null;
}
/**
 * 
 * @export
 * @interface ShardTransferInfo
 */
export interface ShardTransferInfo {
    /**
     * 
     * @type {number}
     * @memberof ShardTransferInfo
     */
    'shard_id': number;
    /**
     * 
     * @type {number}
     * @memberof ShardTransferInfo
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof ShardTransferInfo
     */
    'to': number;
    /**
     * If `true` transfer is a synchronization of a replicas If `false` transfer is a moving of a shard from one peer to another
     * @type {boolean}
     * @memberof ShardTransferInfo
     */
    'sync': boolean;
}
/**
 * 
 * @export
 * @interface SnapshotDescription
 */
export interface SnapshotDescription {
    /**
     * 
     * @type {string}
     * @memberof SnapshotDescription
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotDescription
     */
    'creation_time'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SnapshotDescription
     */
    'size': number;
}
/**
 * Defines source of truth for snapshot recovery `Snapshot` means - prefer snapshot data over the current state `Replica` means - prefer existing data over the snapshot
 * @export
 * @enum {string}
 */

export const SnapshotPriority = {
    Snapshot: 'snapshot',
    Replica: 'replica'
} as const;

export type SnapshotPriority = typeof SnapshotPriority[keyof typeof SnapshotPriority];


/**
 * 
 * @export
 * @interface SnapshotRecover
 */
export interface SnapshotRecover {
    /**
     * Examples: - URL `http://localhost:8080/collections/my_collection/snapshots/my_snapshot` - Local path `file:///qdrant/snapshots/test_collection-2022-08-04-10-49-10.snapshot`
     * @type {string}
     * @memberof SnapshotRecover
     */
    'location': string;
    /**
     * 
     * @type {SnapshotRecoverPriority}
     * @memberof SnapshotRecover
     */
    'priority'?: SnapshotRecoverPriority;
}
/**
 * Defines which data should be used as a source of truth if there are other replicas in the cluster. If set to `Snapshot`, the snapshot will be used as a source of truth, and the current state will be overwritten. If set to `Replica`, the current state will be used as a source of truth, and after recovery if will be synchronized with the snapshot.
 * @export
 * @interface SnapshotRecoverPriority
 */
export interface SnapshotRecoverPriority {
}
/**
 * Role of the peer in the consensus
 * @export
 * @enum {string}
 */

export const StateRole = {
    Follower: 'Follower',
    Candidate: 'Candidate',
    Leader: 'Leader',
    PreCandidate: 'PreCandidate'
} as const;

export type StateRole = typeof StateRole[keyof typeof StateRole];


/**
 * 
 * @export
 * @interface Telemetry200Response
 */
export interface Telemetry200Response {
    /**
     * Time spent to process this request
     * @type {number}
     * @memberof Telemetry200Response
     */
    'time'?: number;
    /**
     * 
     * @type {string}
     * @memberof Telemetry200Response
     */
    'status'?: Telemetry200ResponseStatusEnum;
    /**
     * 
     * @type {TelemetryData}
     * @memberof Telemetry200Response
     */
    'result'?: TelemetryData;
}

export const Telemetry200ResponseStatusEnum = {
    Ok: 'ok'
} as const;

export type Telemetry200ResponseStatusEnum = typeof Telemetry200ResponseStatusEnum[keyof typeof Telemetry200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface TelemetryData
 */
export interface TelemetryData {
    /**
     * 
     * @type {string}
     * @memberof TelemetryData
     */
    'id': string;
    /**
     * 
     * @type {AppBuildTelemetry}
     * @memberof TelemetryData
     */
    'app': AppBuildTelemetry;
    /**
     * 
     * @type {CollectionsTelemetry}
     * @memberof TelemetryData
     */
    'collections': CollectionsTelemetry;
    /**
     * 
     * @type {ClusterTelemetry}
     * @memberof TelemetryData
     */
    'cluster': ClusterTelemetry;
    /**
     * 
     * @type {RequestsTelemetry}
     * @memberof TelemetryData
     */
    'requests': RequestsTelemetry;
}
/**
 * 
 * @export
 * @interface TextIndexParams
 */
export interface TextIndexParams {
    /**
     * 
     * @type {TextIndexType}
     * @memberof TextIndexParams
     */
    'type': TextIndexType;
    /**
     * 
     * @type {TokenizerType}
     * @memberof TextIndexParams
     */
    'tokenizer'?: TokenizerType;
    /**
     * 
     * @type {number}
     * @memberof TextIndexParams
     */
    'min_token_len'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TextIndexParams
     */
    'max_token_len'?: number | null;
    /**
     * If true, lowercase all tokens. Default: true
     * @type {boolean}
     * @memberof TextIndexParams
     */
    'lowercase'?: boolean | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TextIndexType = {
    Text: 'text'
} as const;

export type TextIndexType = typeof TextIndexType[keyof typeof TextIndexType];


/**
 * 
 * @export
 * @enum {string}
 */

export const TokenizerType = {
    Prefix: 'prefix',
    Whitespace: 'whitespace',
    Word: 'word'
} as const;

export type TokenizerType = typeof TokenizerType[keyof typeof TokenizerType];


/**
 * Operation for updating parameters of the existing collection
 * @export
 * @interface UpdateCollection
 */
export interface UpdateCollection {
    /**
     * 
     * @type {UpdateCollectionOptimizersConfig}
     * @memberof UpdateCollection
     */
    'optimizers_config'?: UpdateCollectionOptimizersConfig;
    /**
     * 
     * @type {UpdateCollectionParams}
     * @memberof UpdateCollection
     */
    'params'?: UpdateCollectionParams;
}
/**
 * Custom params for Optimizers.  If none - values from service configuration file are used. This operation is blocking, it will only proceed ones all current optimizations are complete
 * @export
 * @interface UpdateCollectionOptimizersConfig
 */
export interface UpdateCollectionOptimizersConfig {
    /**
     * The minimal fraction of deleted vectors in a segment, required to perform segment optimization
     * @type {number}
     * @memberof UpdateCollectionOptimizersConfig
     */
    'deleted_threshold'?: number | null;
    /**
     * The minimal number of vectors in a segment, required to perform segment optimization
     * @type {number}
     * @memberof UpdateCollectionOptimizersConfig
     */
    'vacuum_min_vector_number'?: number | null;
    /**
     * Target amount of segments optimizer will try to keep. Real amount of segments may vary depending on multiple parameters: - Amount of stored points - Current write RPS  It is recommended to select default number of segments as a factor of the number of search threads, so that each segment would be handled evenly by one of the threads If `default_segment_number = 0`, will be automatically selected by the number of available CPUs
     * @type {number}
     * @memberof UpdateCollectionOptimizersConfig
     */
    'default_segment_number'?: number | null;
    /**
     * Do not create segments larger this size (in kilobytes). Large segments might require disproportionately long indexation times, therefore it makes sense to limit the size of segments.  If indexation speed have more priority for your - make this parameter lower. If search speed is more important - make this parameter higher. Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof UpdateCollectionOptimizersConfig
     */
    'max_segment_size'?: number | null;
    /**
     * Maximum size (in kilobytes) of vectors to store in-memory per segment. Segments larger than this threshold will be stored as read-only memmaped file.  Memmap storage is disabled by default, to enable it, set this threshold to a reasonable value.  To disable memmap storage, set this to `0`.  Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof UpdateCollectionOptimizersConfig
     */
    'memmap_threshold'?: number | null;
    /**
     * Maximum size (in kilobytes) of vectors allowed for plain index, exceeding this threshold will enable vector indexing  Default value is 20,000, based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md>.  To disable vector indexing, set to `0`.  Note: 1kB = 1 vector of size 256.
     * @type {number}
     * @memberof UpdateCollectionOptimizersConfig
     */
    'indexing_threshold'?: number | null;
    /**
     * Minimum interval between forced flushes.
     * @type {number}
     * @memberof UpdateCollectionOptimizersConfig
     */
    'flush_interval_sec'?: number | null;
    /**
     * Maximum available threads for optimization workers
     * @type {number}
     * @memberof UpdateCollectionOptimizersConfig
     */
    'max_optimization_threads'?: number | null;
}
/**
 * Collection base params.  If none - values from service configuration file are used.
 * @export
 * @interface UpdateCollectionParams
 */
export interface UpdateCollectionParams {
    /**
     * Number of replicas for each shard
     * @type {number}
     * @memberof UpdateCollectionParams
     */
    'replication_factor'?: number | null;
    /**
     * Minimal number successful responses from replicas to consider operation successful
     * @type {number}
     * @memberof UpdateCollectionParams
     */
    'write_consistency_factor'?: number | null;
}
/**
 * 
 * @export
 * @interface UpdateResult
 */
export interface UpdateResult {
    /**
     * Sequential number of the operation
     * @type {number}
     * @memberof UpdateResult
     */
    'operation_id': number;
    /**
     * 
     * @type {UpdateStatus}
     * @memberof UpdateResult
     */
    'status': UpdateStatus;
}


/**
 * `Acknowledged` - Request is saved to WAL and will be process in a queue. `Completed` - Request is completed, changes are actual.
 * @export
 * @enum {string}
 */

export const UpdateStatus = {
    Acknowledged: 'acknowledged',
    Completed: 'completed'
} as const;

export type UpdateStatus = typeof UpdateStatus[keyof typeof UpdateStatus];


/**
 * 
 * @export
 * @interface UpdateVectors
 */
export interface UpdateVectors {
    /**
     * Points with named vectors
     * @type {Array<PointVectors>}
     * @memberof UpdateVectors
     */
    'points': Array<PointVectors>;
}
/**
 * 
 * @export
 * @interface UsingVector
 */
export interface UsingVector {
}
/**
 * 
 * @export
 * @interface ValueVariants
 */
export interface ValueVariants {
}
/**
 * Values count filter request
 * @export
 * @interface ValuesCount
 */
export interface ValuesCount {
    /**
     * point.key.length() < values_count.lt
     * @type {number}
     * @memberof ValuesCount
     */
    'lt'?: number | null;
    /**
     * point.key.length() > values_count.gt
     * @type {number}
     * @memberof ValuesCount
     */
    'gt'?: number | null;
    /**
     * point.key.length() >= values_count.gte
     * @type {number}
     * @memberof ValuesCount
     */
    'gte'?: number | null;
    /**
     * point.key.length() <= values_count.lte
     * @type {number}
     * @memberof ValuesCount
     */
    'lte'?: number | null;
}
/**
 * Config of single vector data storage
 * @export
 * @interface VectorDataConfig
 */
export interface VectorDataConfig {
    /**
     * Size/dimensionality of the vectors used
     * @type {number}
     * @memberof VectorDataConfig
     */
    'size': number;
    /**
     * 
     * @type {Distance}
     * @memberof VectorDataConfig
     */
    'distance': Distance;
    /**
     * 
     * @type {VectorStorageType}
     * @memberof VectorDataConfig
     */
    'storage_type': VectorStorageType;
    /**
     * 
     * @type {Indexes}
     * @memberof VectorDataConfig
     */
    'index': Indexes;
    /**
     * 
     * @type {VectorDataConfigQuantizationConfig}
     * @memberof VectorDataConfig
     */
    'quantization_config'?: VectorDataConfigQuantizationConfig;
}


/**
 * Vector specific quantization config that overrides collection config
 * @export
 * @interface VectorDataConfigQuantizationConfig
 */
export interface VectorDataConfigQuantizationConfig {
    /**
     * 
     * @type {ScalarQuantizationConfig}
     * @memberof VectorDataConfigQuantizationConfig
     */
    'scalar': ScalarQuantizationConfig;
    /**
     * 
     * @type {ProductQuantizationConfig}
     * @memberof VectorDataConfigQuantizationConfig
     */
    'product': ProductQuantizationConfig;
}
/**
 * 
 * @export
 * @interface VectorIndexSearchesTelemetry
 */
export interface VectorIndexSearchesTelemetry {
    /**
     * 
     * @type {string}
     * @memberof VectorIndexSearchesTelemetry
     */
    'index_name'?: string | null;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof VectorIndexSearchesTelemetry
     */
    'unfiltered_plain': OperationDurationStatistics;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof VectorIndexSearchesTelemetry
     */
    'unfiltered_hnsw': OperationDurationStatistics;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof VectorIndexSearchesTelemetry
     */
    'filtered_plain': OperationDurationStatistics;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof VectorIndexSearchesTelemetry
     */
    'filtered_small_cardinality': OperationDurationStatistics;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof VectorIndexSearchesTelemetry
     */
    'filtered_large_cardinality': OperationDurationStatistics;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof VectorIndexSearchesTelemetry
     */
    'filtered_exact': OperationDurationStatistics;
    /**
     * 
     * @type {OperationDurationStatistics}
     * @memberof VectorIndexSearchesTelemetry
     */
    'unfiltered_exact': OperationDurationStatistics;
}
/**
 * Params of single vector data storage
 * @export
 * @interface VectorParams
 */
export interface VectorParams {
    /**
     * Size of a vectors used
     * @type {number}
     * @memberof VectorParams
     */
    'size': number;
    /**
     * 
     * @type {Distance}
     * @memberof VectorParams
     */
    'distance': Distance;
    /**
     * 
     * @type {VectorParamsHnswConfig}
     * @memberof VectorParams
     */
    'hnsw_config'?: VectorParamsHnswConfig;
    /**
     * 
     * @type {VectorParamsQuantizationConfig}
     * @memberof VectorParams
     */
    'quantization_config'?: VectorParamsQuantizationConfig;
    /**
     * If true, vectors are served from disk, improving RAM usage at the cost of latency Default: false
     * @type {boolean}
     * @memberof VectorParams
     */
    'on_disk'?: boolean | null;
}


/**
 * Custom params for HNSW index. If none - values from collection configuration are used.
 * @export
 * @interface VectorParamsHnswConfig
 */
export interface VectorParamsHnswConfig {
    /**
     * Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
     * @type {number}
     * @memberof VectorParamsHnswConfig
     */
    'm'?: number | null;
    /**
     * Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build the index.
     * @type {number}
     * @memberof VectorParamsHnswConfig
     */
    'ef_construct'?: number | null;
    /**
     * Minimal size (in kilobytes) of vectors for additional payload-based indexing. If payload chunk is smaller than `full_scan_threshold_kb` additional indexing won\'t be used - in this case full-scan search should be preferred by query planner and additional indexing is not required. Note: 1Kb = 1 vector of size 256
     * @type {number}
     * @memberof VectorParamsHnswConfig
     */
    'full_scan_threshold'?: number | null;
    /**
     * Number of parallel threads used for background index building. If 0 - auto selection.
     * @type {number}
     * @memberof VectorParamsHnswConfig
     */
    'max_indexing_threads'?: number | null;
    /**
     * Store HNSW index on disk. If set to false, the index will be stored in RAM. Default: false
     * @type {boolean}
     * @memberof VectorParamsHnswConfig
     */
    'on_disk'?: boolean | null;
    /**
     * Custom M param for additional payload-aware HNSW links. If not set, default M will be used.
     * @type {number}
     * @memberof VectorParamsHnswConfig
     */
    'payload_m'?: number | null;
}
/**
 * Custom params for quantization. If none - values from collection configuration are used.
 * @export
 * @interface VectorParamsQuantizationConfig
 */
export interface VectorParamsQuantizationConfig {
    /**
     * 
     * @type {ScalarQuantizationConfig}
     * @memberof VectorParamsQuantizationConfig
     */
    'scalar': ScalarQuantizationConfig;
    /**
     * 
     * @type {ProductQuantizationConfig}
     * @memberof VectorParamsQuantizationConfig
     */
    'product': ProductQuantizationConfig;
}
/**
 * @type VectorStorageType
 * Storage types for vectors
 * @export
 */
export type VectorStorageType = string;

/**
 * Full vector data per point separator with single and multiple vector modes
 * @export
 * @interface VectorStruct
 */
export interface VectorStruct {
}
/**
 * Vector params separator for single and multiple vector modes Single mode:  { \"size\": 128, \"distance\": \"Cosine\" }  or multiple mode:  { \"default\": { \"size\": 128, \"distance\": \"Cosine\" } }
 * @export
 * @interface VectorsConfig
 */
export interface VectorsConfig {
    /**
     * Size of a vectors used
     * @type {number}
     * @memberof VectorsConfig
     */
    'size': number;
    /**
     * 
     * @type {Distance}
     * @memberof VectorsConfig
     */
    'distance': Distance;
    /**
     * 
     * @type {VectorParamsHnswConfig}
     * @memberof VectorsConfig
     */
    'hnsw_config'?: VectorParamsHnswConfig;
    /**
     * 
     * @type {VectorParamsQuantizationConfig}
     * @memberof VectorsConfig
     */
    'quantization_config'?: VectorParamsQuantizationConfig;
    /**
     * If true, vectors are served from disk, improving RAM usage at the cost of latency Default: false
     * @type {boolean}
     * @memberof VectorsConfig
     */
    'on_disk'?: boolean | null;
}


/**
 * 
 * @export
 * @interface WalConfig
 */
export interface WalConfig {
    /**
     * Size of a single WAL segment in MB
     * @type {number}
     * @memberof WalConfig
     */
    'wal_capacity_mb': number;
    /**
     * Number of WAL segments to create ahead of actually used ones
     * @type {number}
     * @memberof WalConfig
     */
    'wal_segments_ahead': number;
}
/**
 * 
 * @export
 * @interface WalConfigDiff
 */
export interface WalConfigDiff {
    /**
     * Size of a single WAL segment in MB
     * @type {number}
     * @memberof WalConfigDiff
     */
    'wal_capacity_mb'?: number | null;
    /**
     * Number of WAL segments to create ahead of actually used ones
     * @type {number}
     * @memberof WalConfigDiff
     */
    'wal_segments_ahead'?: number | null;
}
/**
 * 
 * @export
 * @interface WebApiTelemetry
 */
export interface WebApiTelemetry {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: OperationDurationStatistics; }; }}
     * @memberof WebApiTelemetry
     */
    'responses': { [key: string]: { [key: string]: OperationDurationStatistics; }; };
}
/**
 * Options for specifying which payload to include or not
 * @export
 * @interface WithPayloadInterface
 */
export interface WithPayloadInterface {
    /**
     * Only include this payload keys
     * @type {Array<string>}
     * @memberof WithPayloadInterface
     */
    'include': Array<string>;
    /**
     * Exclude this fields from returning payload
     * @type {Array<string>}
     * @memberof WithPayloadInterface
     */
    'exclude': Array<string>;
}
/**
 * Options for specifying which vector to include
 * @export
 * @interface WithVector
 */
export interface WithVector {
}
/**
 * Defines write ordering guarantees for collection operations  * `weak` - write operations may be reordered, works faster, default  * `medium` - write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change  * `strong` - Write operations go through the permanent leader, consistent, but may be unavailable if leader is down
 * @export
 * @enum {string}
 */

export const WriteOrdering = {
    Weak: 'weak',
    Medium: 'medium',
    Strong: 'strong'
} as const;

export type WriteOrdering = typeof WriteOrdering[keyof typeof WriteOrdering];



/**
 * ClusterApi - axios parameter creator
 * @export
 */
export const ClusterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information about the current state and composition of the cluster
         * @summary Get cluster status info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cluster`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get cluster information for a collection
         * @summary Collection cluster info
         * @param {string} collectionName Name of the collection to retrieve the cluster info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionClusterInfo: async (collectionName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('collectionClusterInfo', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/cluster`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tries to recover current peer Raft state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverCurrentPeer: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cluster/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tries to remove peer from the cluster. Will return an error if peer has shards on it.
         * @summary Remove peer from the cluster
         * @param {number} peerId Id of the peer
         * @param {boolean} [force] If true - removes peer even if it has shards/replicas on it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePeer: async (peerId: number, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'peerId' is not null or undefined
            assertParamExists('removePeer', 'peerId', peerId)
            const localVarPath = `/cluster/peer/{peer_id}`
                .replace(`{${"peer_id"}}`, encodeURIComponent(String(peerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update collection cluster setup
         * @param {string} collectionName Name of the collection on which to to apply the cluster update operation
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {ClusterOperations} [clusterOperations] Collection cluster update operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollectionCluster: async (collectionName: string, timeout?: number, clusterOperations?: ClusterOperations, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('updateCollectionCluster', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/cluster`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterOperations, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterApi - functional programming interface
 * @export
 */
export const ClusterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information about the current state and composition of the cluster
         * @summary Get cluster status info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get cluster information for a collection
         * @summary Collection cluster info
         * @param {string} collectionName Name of the collection to retrieve the cluster info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionClusterInfo(collectionName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionClusterInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionClusterInfo(collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Tries to recover current peer Raft state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverCurrentPeer(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverCurrentPeer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tries to remove peer from the cluster. Will return an error if peer has shards on it.
         * @summary Remove peer from the cluster
         * @param {number} peerId Id of the peer
         * @param {boolean} [force] If true - removes peer even if it has shards/replicas on it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePeer(peerId: number, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePeer(peerId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update collection cluster setup
         * @param {string} collectionName Name of the collection on which to to apply the cluster update operation
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {ClusterOperations} [clusterOperations] Collection cluster update operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollectionCluster(collectionName: string, timeout?: number, clusterOperations?: ClusterOperations, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollectionCluster(collectionName, timeout, clusterOperations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClusterApi - factory interface
 * @export
 */
export const ClusterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterApiFp(configuration)
    return {
        /**
         * Get information about the current state and composition of the cluster
         * @summary Get cluster status info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterStatus(options?: any): AxiosPromise<ClusterStatus200Response> {
            return localVarFp.clusterStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get cluster information for a collection
         * @summary Collection cluster info
         * @param {string} collectionName Name of the collection to retrieve the cluster info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionClusterInfo(collectionName: string, options?: any): AxiosPromise<CollectionClusterInfo200Response> {
            return localVarFp.collectionClusterInfo(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tries to recover current peer Raft state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverCurrentPeer(options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.recoverCurrentPeer(options).then((request) => request(axios, basePath));
        },
        /**
         * Tries to remove peer from the cluster. Will return an error if peer has shards on it.
         * @summary Remove peer from the cluster
         * @param {number} peerId Id of the peer
         * @param {boolean} [force] If true - removes peer even if it has shards/replicas on it.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePeer(peerId: number, force?: boolean, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.removePeer(peerId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update collection cluster setup
         * @param {string} collectionName Name of the collection on which to to apply the cluster update operation
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {ClusterOperations} [clusterOperations] Collection cluster update operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollectionCluster(collectionName: string, timeout?: number, clusterOperations?: ClusterOperations, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.updateCollectionCluster(collectionName, timeout, clusterOperations, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClusterApi - object-oriented interface
 * @export
 * @class ClusterApi
 * @extends {BaseAPI}
 */
export class ClusterApi extends BaseAPI {
    /**
     * Get information about the current state and composition of the cluster
     * @summary Get cluster status info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public clusterStatus(options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).clusterStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get cluster information for a collection
     * @summary Collection cluster info
     * @param {string} collectionName Name of the collection to retrieve the cluster info for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public collectionClusterInfo(collectionName: string, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).collectionClusterInfo(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tries to recover current peer Raft state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public recoverCurrentPeer(options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).recoverCurrentPeer(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tries to remove peer from the cluster. Will return an error if peer has shards on it.
     * @summary Remove peer from the cluster
     * @param {number} peerId Id of the peer
     * @param {boolean} [force] If true - removes peer even if it has shards/replicas on it.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public removePeer(peerId: number, force?: boolean, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).removePeer(peerId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update collection cluster setup
     * @param {string} collectionName Name of the collection on which to to apply the cluster update operation
     * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
     * @param {ClusterOperations} [clusterOperations] Collection cluster update operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public updateCollectionCluster(collectionName: string, timeout?: number, clusterOperations?: ClusterOperations, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).updateCollectionCluster(collectionName, timeout, clusterOperations, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get cluster information for a collection
         * @summary Collection cluster info
         * @param {string} collectionName Name of the collection to retrieve the cluster info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionClusterInfo: async (collectionName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('collectionClusterInfo', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/cluster`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new collection with given parameters
         * @summary Create collection
         * @param {string} collectionName Name of the new collection
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {CreateCollection} [createCollection] Parameters of a new collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (collectionName: string, timeout?: number, createCollection?: CreateCollection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('createCollection', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create index for field in collection
         * @summary Create index for field in collection
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {CreateFieldIndex} [createFieldIndex] Field name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFieldIndex: async (collectionName: string, wait?: boolean, ordering?: WriteOrdering, createFieldIndex?: CreateFieldIndex, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('createFieldIndex', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/index`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFieldIndex, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new snapshot for a collection
         * @summary Create collection snapshot
         * @param {string} collectionName Name of the collection for which to create a snapshot
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot: async (collectionName: string, wait?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('createSnapshot', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/snapshots`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Drop collection and all associated data
         * @summary Delete collection
         * @param {string} collectionName Name of the collection to delete
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection: async (collectionName: string, timeout?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deleteCollection', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete field index for collection
         * @summary Delete index for field in collection
         * @param {string} collectionName Name of the collection
         * @param {string} fieldName Name of the field where to delete the index
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldIndex: async (collectionName: string, fieldName: string, wait?: boolean, ordering?: WriteOrdering, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deleteFieldIndex', 'collectionName', collectionName)
            // verify required parameter 'fieldName' is not null or undefined
            assertParamExists('deleteFieldIndex', 'fieldName', fieldName)
            const localVarPath = `/collections/{collection_name}/index/{field_name}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)))
                .replace(`{${"field_name"}}`, encodeURIComponent(String(fieldName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete snapshot for a collection
         * @summary Delete collection snapshot
         * @param {string} collectionName Name of the collection for which to delete a snapshot
         * @param {string} snapshotName Name of the snapshot to delete
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot: async (collectionName: string, snapshotName: string, wait?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deleteSnapshot', 'collectionName', collectionName)
            // verify required parameter 'snapshotName' is not null or undefined
            assertParamExists('deleteSnapshot', 'snapshotName', snapshotName)
            const localVarPath = `/collections/{collection_name}/snapshots/{snapshot_name}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)))
                .replace(`{${"snapshot_name"}}`, encodeURIComponent(String(snapshotName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about specified existing collection
         * @summary Collection info
         * @param {string} collectionName Name of the collection to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (collectionName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('getCollection', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all aliases for a collection
         * @summary List aliases for collection
         * @param {string} collectionName Name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionAliases: async (collectionName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('getCollectionAliases', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/aliases`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list name of all existing collections
         * @summary List collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all existing collections aliases
         * @summary List collections aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsAliases: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aliases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download specified snapshot from a collection as a file
         * @summary Download collection snapshot
         * @param {string} collectionName Name of the collection
         * @param {string} snapshotName Name of the snapshot to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot: async (collectionName: string, snapshotName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('getSnapshot', 'collectionName', collectionName)
            // verify required parameter 'snapshotName' is not null or undefined
            assertParamExists('getSnapshot', 'snapshotName', snapshotName)
            const localVarPath = `/collections/{collection_name}/snapshots/{snapshot_name}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)))
                .replace(`{${"snapshot_name"}}`, encodeURIComponent(String(snapshotName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of snapshots for a collection
         * @summary List collection snapshots
         * @param {string} collectionName Name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshots: async (collectionName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('listSnapshots', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/snapshots`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from a snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotRecover} [snapshotRecover] Snapshot to recover from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverFromSnapshot: async (collectionName: string, wait?: boolean, snapshotRecover?: SnapshotRecover, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('recoverFromSnapshot', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/snapshots/recover`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(snapshotRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from an uploaded snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotPriority} [priority] Defines source of truth for snapshot recovery
         * @param {File} [snapshot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverFromUploadedSnapshot: async (collectionName: string, wait?: boolean, priority?: SnapshotPriority, snapshot?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('recoverFromUploadedSnapshot', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/snapshots/upload`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }


            if (snapshot !== undefined) { 
                localVarFormParams.append('snapshot', snapshot as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update aliases of the collections
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {ChangeAliasesOperation} [changeAliasesOperation] Alias update operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAliases: async (timeout?: number, changeAliasesOperation?: ChangeAliasesOperation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections/aliases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeAliasesOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update parameters of the existing collection
         * @summary Update collection parameters
         * @param {string} collectionName Name of the collection to update
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {UpdateCollection} [updateCollection] New parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection: async (collectionName: string, timeout?: number, updateCollection?: UpdateCollection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('updateCollection', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update collection cluster setup
         * @param {string} collectionName Name of the collection on which to to apply the cluster update operation
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {ClusterOperations} [clusterOperations] Collection cluster update operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollectionCluster: async (collectionName: string, timeout?: number, clusterOperations?: ClusterOperations, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('updateCollectionCluster', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/cluster`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterOperations, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get cluster information for a collection
         * @summary Collection cluster info
         * @param {string} collectionName Name of the collection to retrieve the cluster info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectionClusterInfo(collectionName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionClusterInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectionClusterInfo(collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new collection with given parameters
         * @summary Create collection
         * @param {string} collectionName Name of the new collection
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {CreateCollection} [createCollection] Parameters of a new collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(collectionName: string, timeout?: number, createCollection?: CreateCollection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCollection(collectionName, timeout, createCollection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create index for field in collection
         * @summary Create index for field in collection
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {CreateFieldIndex} [createFieldIndex] Field name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFieldIndex(collectionName: string, wait?: boolean, ordering?: WriteOrdering, createFieldIndex?: CreateFieldIndex, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFieldIndex(collectionName, wait, ordering, createFieldIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new snapshot for a collection
         * @summary Create collection snapshot
         * @param {string} collectionName Name of the collection for which to create a snapshot
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSnapshot(collectionName: string, wait?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSnapshot(collectionName, wait, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Drop collection and all associated data
         * @summary Delete collection
         * @param {string} collectionName Name of the collection to delete
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollection(collectionName: string, timeout?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCollection(collectionName, timeout, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete field index for collection
         * @summary Delete index for field in collection
         * @param {string} collectionName Name of the collection
         * @param {string} fieldName Name of the field where to delete the index
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFieldIndex(collectionName: string, fieldName: string, wait?: boolean, ordering?: WriteOrdering, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFieldIndex(collectionName, fieldName, wait, ordering, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete snapshot for a collection
         * @summary Delete collection snapshot
         * @param {string} collectionName Name of the collection for which to delete a snapshot
         * @param {string} snapshotName Name of the snapshot to delete
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSnapshot(collectionName: string, snapshotName: string, wait?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSnapshot(collectionName, snapshotName, wait, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get detailed information about specified existing collection
         * @summary Collection info
         * @param {string} collectionName Name of the collection to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(collectionName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of all aliases for a collection
         * @summary List aliases for collection
         * @param {string} collectionName Name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionAliases(collectionName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollectionAliases200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionAliases(collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list name of all existing collections
         * @summary List collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollections200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollections(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of all existing collections aliases
         * @summary List collections aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionsAliases(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollectionAliases200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionsAliases(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download specified snapshot from a collection as a file
         * @summary Download collection snapshot
         * @param {string} collectionName Name of the collection
         * @param {string} snapshotName Name of the snapshot to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshot(collectionName: string, snapshotName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshot(collectionName, snapshotName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of snapshots for a collection
         * @summary List collection snapshots
         * @param {string} collectionName Name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSnapshots(collectionName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSnapshots200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSnapshots(collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from a snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotRecover} [snapshotRecover] Snapshot to recover from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverFromSnapshot(collectionName: string, wait?: boolean, snapshotRecover?: SnapshotRecover, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverFromSnapshot(collectionName, wait, snapshotRecover, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from an uploaded snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotPriority} [priority] Defines source of truth for snapshot recovery
         * @param {File} [snapshot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverFromUploadedSnapshot(collectionName: string, wait?: boolean, priority?: SnapshotPriority, snapshot?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverFromUploadedSnapshot(collectionName, wait, priority, snapshot, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update aliases of the collections
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {ChangeAliasesOperation} [changeAliasesOperation] Alias update operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAliases(timeout?: number, changeAliasesOperation?: ChangeAliasesOperation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAliases(timeout, changeAliasesOperation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update parameters of the existing collection
         * @summary Update collection parameters
         * @param {string} collectionName Name of the collection to update
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {UpdateCollection} [updateCollection] New parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollection(collectionName: string, timeout?: number, updateCollection?: UpdateCollection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollection(collectionName, timeout, updateCollection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update collection cluster setup
         * @param {string} collectionName Name of the collection on which to to apply the cluster update operation
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {ClusterOperations} [clusterOperations] Collection cluster update operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCollectionCluster(collectionName: string, timeout?: number, clusterOperations?: ClusterOperations, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCollectionCluster(collectionName, timeout, clusterOperations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * Get cluster information for a collection
         * @summary Collection cluster info
         * @param {string} collectionName Name of the collection to retrieve the cluster info for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionClusterInfo(collectionName: string, options?: any): AxiosPromise<CollectionClusterInfo200Response> {
            return localVarFp.collectionClusterInfo(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new collection with given parameters
         * @summary Create collection
         * @param {string} collectionName Name of the new collection
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {CreateCollection} [createCollection] Parameters of a new collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(collectionName: string, timeout?: number, createCollection?: CreateCollection, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.createCollection(collectionName, timeout, createCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * Create index for field in collection
         * @summary Create index for field in collection
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {CreateFieldIndex} [createFieldIndex] Field name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFieldIndex(collectionName: string, wait?: boolean, ordering?: WriteOrdering, createFieldIndex?: CreateFieldIndex, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.createFieldIndex(collectionName, wait, ordering, createFieldIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new snapshot for a collection
         * @summary Create collection snapshot
         * @param {string} collectionName Name of the collection for which to create a snapshot
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot(collectionName: string, wait?: boolean, options?: any): AxiosPromise<CreateSnapshot200Response> {
            return localVarFp.createSnapshot(collectionName, wait, options).then((request) => request(axios, basePath));
        },
        /**
         * Drop collection and all associated data
         * @summary Delete collection
         * @param {string} collectionName Name of the collection to delete
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(collectionName: string, timeout?: number, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.deleteCollection(collectionName, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete field index for collection
         * @summary Delete index for field in collection
         * @param {string} collectionName Name of the collection
         * @param {string} fieldName Name of the field where to delete the index
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFieldIndex(collectionName: string, fieldName: string, wait?: boolean, ordering?: WriteOrdering, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.deleteFieldIndex(collectionName, fieldName, wait, ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete snapshot for a collection
         * @summary Delete collection snapshot
         * @param {string} collectionName Name of the collection for which to delete a snapshot
         * @param {string} snapshotName Name of the snapshot to delete
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(collectionName: string, snapshotName: string, wait?: boolean, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.deleteSnapshot(collectionName, snapshotName, wait, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about specified existing collection
         * @summary Collection info
         * @param {string} collectionName Name of the collection to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(collectionName: string, options?: any): AxiosPromise<GetCollection200Response> {
            return localVarFp.getCollection(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all aliases for a collection
         * @summary List aliases for collection
         * @param {string} collectionName Name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionAliases(collectionName: string, options?: any): AxiosPromise<GetCollectionAliases200Response> {
            return localVarFp.getCollectionAliases(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list name of all existing collections
         * @summary List collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections(options?: any): AxiosPromise<GetCollections200Response> {
            return localVarFp.getCollections(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of all existing collections aliases
         * @summary List collections aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsAliases(options?: any): AxiosPromise<GetCollectionAliases200Response> {
            return localVarFp.getCollectionsAliases(options).then((request) => request(axios, basePath));
        },
        /**
         * Download specified snapshot from a collection as a file
         * @summary Download collection snapshot
         * @param {string} collectionName Name of the collection
         * @param {string} snapshotName Name of the snapshot to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot(collectionName: string, snapshotName: string, options?: any): AxiosPromise<File> {
            return localVarFp.getSnapshot(collectionName, snapshotName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of snapshots for a collection
         * @summary List collection snapshots
         * @param {string} collectionName Name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshots(collectionName: string, options?: any): AxiosPromise<ListSnapshots200Response> {
            return localVarFp.listSnapshots(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from a snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotRecover} [snapshotRecover] Snapshot to recover from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverFromSnapshot(collectionName: string, wait?: boolean, snapshotRecover?: SnapshotRecover, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.recoverFromSnapshot(collectionName, wait, snapshotRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from an uploaded snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotPriority} [priority] Defines source of truth for snapshot recovery
         * @param {File} [snapshot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverFromUploadedSnapshot(collectionName: string, wait?: boolean, priority?: SnapshotPriority, snapshot?: File, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.recoverFromUploadedSnapshot(collectionName, wait, priority, snapshot, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update aliases of the collections
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {ChangeAliasesOperation} [changeAliasesOperation] Alias update operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAliases(timeout?: number, changeAliasesOperation?: ChangeAliasesOperation, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.updateAliases(timeout, changeAliasesOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update parameters of the existing collection
         * @summary Update collection parameters
         * @param {string} collectionName Name of the collection to update
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {UpdateCollection} [updateCollection] New parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(collectionName: string, timeout?: number, updateCollection?: UpdateCollection, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.updateCollection(collectionName, timeout, updateCollection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update collection cluster setup
         * @param {string} collectionName Name of the collection on which to to apply the cluster update operation
         * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
         * @param {ClusterOperations} [clusterOperations] Collection cluster update operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollectionCluster(collectionName: string, timeout?: number, clusterOperations?: ClusterOperations, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.updateCollectionCluster(collectionName, timeout, clusterOperations, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Get cluster information for a collection
     * @summary Collection cluster info
     * @param {string} collectionName Name of the collection to retrieve the cluster info for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public collectionClusterInfo(collectionName: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).collectionClusterInfo(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new collection with given parameters
     * @summary Create collection
     * @param {string} collectionName Name of the new collection
     * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
     * @param {CreateCollection} [createCollection] Parameters of a new collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public createCollection(collectionName: string, timeout?: number, createCollection?: CreateCollection, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).createCollection(collectionName, timeout, createCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create index for field in collection
     * @summary Create index for field in collection
     * @param {string} collectionName Name of the collection
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {CreateFieldIndex} [createFieldIndex] Field name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public createFieldIndex(collectionName: string, wait?: boolean, ordering?: WriteOrdering, createFieldIndex?: CreateFieldIndex, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).createFieldIndex(collectionName, wait, ordering, createFieldIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new snapshot for a collection
     * @summary Create collection snapshot
     * @param {string} collectionName Name of the collection for which to create a snapshot
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public createSnapshot(collectionName: string, wait?: boolean, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).createSnapshot(collectionName, wait, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Drop collection and all associated data
     * @summary Delete collection
     * @param {string} collectionName Name of the collection to delete
     * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollection(collectionName: string, timeout?: number, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).deleteCollection(collectionName, timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete field index for collection
     * @summary Delete index for field in collection
     * @param {string} collectionName Name of the collection
     * @param {string} fieldName Name of the field where to delete the index
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteFieldIndex(collectionName: string, fieldName: string, wait?: boolean, ordering?: WriteOrdering, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).deleteFieldIndex(collectionName, fieldName, wait, ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete snapshot for a collection
     * @summary Delete collection snapshot
     * @param {string} collectionName Name of the collection for which to delete a snapshot
     * @param {string} snapshotName Name of the snapshot to delete
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteSnapshot(collectionName: string, snapshotName: string, wait?: boolean, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).deleteSnapshot(collectionName, snapshotName, wait, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about specified existing collection
     * @summary Collection info
     * @param {string} collectionName Name of the collection to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollection(collectionName: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollection(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all aliases for a collection
     * @summary List aliases for collection
     * @param {string} collectionName Name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionAliases(collectionName: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollectionAliases(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list name of all existing collections
     * @summary List collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollections(options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of all existing collections aliases
     * @summary List collections aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionsAliases(options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollectionsAliases(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download specified snapshot from a collection as a file
     * @summary Download collection snapshot
     * @param {string} collectionName Name of the collection
     * @param {string} snapshotName Name of the snapshot to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getSnapshot(collectionName: string, snapshotName: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getSnapshot(collectionName, snapshotName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of snapshots for a collection
     * @summary List collection snapshots
     * @param {string} collectionName Name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public listSnapshots(collectionName: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).listSnapshots(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
     * @summary Recover from a snapshot
     * @param {string} collectionName Name of the collection
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {SnapshotRecover} [snapshotRecover] Snapshot to recover from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public recoverFromSnapshot(collectionName: string, wait?: boolean, snapshotRecover?: SnapshotRecover, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).recoverFromSnapshot(collectionName, wait, snapshotRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
     * @summary Recover from an uploaded snapshot
     * @param {string} collectionName Name of the collection
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {SnapshotPriority} [priority] Defines source of truth for snapshot recovery
     * @param {File} [snapshot] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public recoverFromUploadedSnapshot(collectionName: string, wait?: boolean, priority?: SnapshotPriority, snapshot?: File, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).recoverFromUploadedSnapshot(collectionName, wait, priority, snapshot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update aliases of the collections
     * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
     * @param {ChangeAliasesOperation} [changeAliasesOperation] Alias update operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public updateAliases(timeout?: number, changeAliasesOperation?: ChangeAliasesOperation, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).updateAliases(timeout, changeAliasesOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update parameters of the existing collection
     * @summary Update collection parameters
     * @param {string} collectionName Name of the collection to update
     * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
     * @param {UpdateCollection} [updateCollection] New parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public updateCollection(collectionName: string, timeout?: number, updateCollection?: UpdateCollection, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).updateCollection(collectionName, timeout, updateCollection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update collection cluster setup
     * @param {string} collectionName Name of the collection on which to to apply the cluster update operation
     * @param {number} [timeout] Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error. 
     * @param {ClusterOperations} [clusterOperations] Collection cluster update operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public updateCollectionCluster(collectionName: string, timeout?: number, clusterOperations?: ClusterOperations, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).updateCollectionCluster(collectionName, timeout, clusterOperations, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PointsApi - axios parameter creator
 * @export
 */
export const PointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove all payload for specified points
         * @summary Clear payload
         * @param {string} collectionName Name of the collection to clear payload from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {PointsSelector} [pointsSelector] clear payload on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearPayload: async (collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointsSelector?: PointsSelector, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('clearPayload', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/payload/clear`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointsSelector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Count points which matches given filtering condition
         * @summary Count points
         * @param {string} collectionName Name of the collection to count in
         * @param {CountRequest} [countRequest] Request counts of points which matches given filtering condition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countPoints: async (collectionName: string, countRequest?: CountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('countPoints', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/count`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(countRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete specified key payload for points
         * @summary Delete payload
         * @param {string} collectionName Name of the collection to delete from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {DeletePayload} [deletePayload] delete payload on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayload: async (collectionName: string, wait?: boolean, ordering?: WriteOrdering, deletePayload?: DeletePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deletePayload', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/payload/delete`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete points
         * @summary Delete points
         * @param {string} collectionName Name of the collection to delete from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {PointsSelector} [pointsSelector] Operation to perform on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoints: async (collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointsSelector?: PointsSelector, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deletePoints', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/delete`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointsSelector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete named vectors from the given points.
         * @summary Delete vectors
         * @param {string} collectionName Name of the collection to delete from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {DeleteVectors} [deleteVectors] Delete named vectors from points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVectors: async (collectionName: string, wait?: boolean, ordering?: WriteOrdering, deleteVectors?: DeleteVectors, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deleteVectors', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/vectors/delete`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteVectors, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve full information of single point by id
         * @summary Get point
         * @param {string} collectionName Name of the collection to retrieve from
         * @param {ExtendedPointId} id Id of the point
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoint: async (collectionName: string, id: ExtendedPointId, consistency?: ReadConsistency, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('getPoint', 'collectionName', collectionName)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPoint', 'id', id)
            const localVarPath = `/collections/{collection_name}/points/{id}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consistency !== undefined) {
                localVarQueryParameter['consistency'] = consistency;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve multiple points by specified IDs
         * @summary Get points
         * @param {string} collectionName Name of the collection to retrieve from
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {PointRequest} [pointRequest] List of points to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoints: async (collectionName: string, consistency?: ReadConsistency, pointRequest?: PointRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('getPoints', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consistency !== undefined) {
                localVarQueryParameter['consistency'] = consistency;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace full payload of points with new one
         * @summary Overwrite payload
         * @param {string} collectionName Name of the collection to set from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {SetPayload} [setPayload] Payload and points selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overwritePayload: async (collectionName: string, wait?: boolean, ordering?: WriteOrdering, setPayload?: SetPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('overwritePayload', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/payload`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         * @summary Recommend batch points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {RecommendRequestBatch} [recommendRequestBatch] Request points based on positive and negative examples.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendBatchPoints: async (collectionName: string, consistency?: ReadConsistency, recommendRequestBatch?: RecommendRequestBatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('recommendBatchPoints', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/recommend/batch`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consistency !== undefined) {
                localVarQueryParameter['consistency'] = consistency;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendRequestBatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given payload field.
         * @summary Recommend point groups
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {RecommendGroupsRequest} [recommendGroupsRequest] Request points based on positive and negative examples, grouped by a payload field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendPointGroups: async (collectionName: string, consistency?: ReadConsistency, recommendGroupsRequest?: RecommendGroupsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('recommendPointGroups', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/recommend/groups`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consistency !== undefined) {
                localVarQueryParameter['consistency'] = consistency;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendGroupsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         * @summary Recommend points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {RecommendRequest} [recommendRequest] Request points based on positive and negative examples.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendPoints: async (collectionName: string, consistency?: ReadConsistency, recommendRequest?: RecommendRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('recommendPoints', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/recommend`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consistency !== undefined) {
                localVarQueryParameter['consistency'] = consistency;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recommendRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Scroll request - paginate over all points which matches given filtering condition
         * @summary Scroll points
         * @param {string} collectionName Name of the collection to retrieve from
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {ScrollRequest} [scrollRequest] Pagination and filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrollPoints: async (collectionName: string, consistency?: ReadConsistency, scrollRequest?: ScrollRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('scrollPoints', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/scroll`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consistency !== undefined) {
                localVarQueryParameter['consistency'] = consistency;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scrollRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve by batch the closest points based on vector similarity and given filtering conditions
         * @summary Search batch points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {SearchRequestBatch} [searchRequestBatch] Search batch request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBatchPoints: async (collectionName: string, consistency?: ReadConsistency, searchRequestBatch?: SearchRequestBatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('searchBatchPoints', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/search/batch`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consistency !== undefined) {
                localVarQueryParameter['consistency'] = consistency;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequestBatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given payload field
         * @summary Search point groups
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {SearchGroupsRequest} [searchGroupsRequest] Search request with optional filtering, grouped by a given payload field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPointGroups: async (collectionName: string, consistency?: ReadConsistency, searchGroupsRequest?: SearchGroupsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('searchPointGroups', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/search/groups`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consistency !== undefined) {
                localVarQueryParameter['consistency'] = consistency;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchGroupsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve closest points based on vector similarity and given filtering conditions
         * @summary Search points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {SearchRequest} [searchRequest] Search request with optional filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPoints: async (collectionName: string, consistency?: ReadConsistency, searchRequest?: SearchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('searchPoints', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/search`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (consistency !== undefined) {
                localVarQueryParameter['consistency'] = consistency;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set payload values for points
         * @summary Set payload
         * @param {string} collectionName Name of the collection to set from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {SetPayload} [setPayload] Set payload on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayload: async (collectionName: string, wait?: boolean, ordering?: WriteOrdering, setPayload?: SetPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('setPayload', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/payload`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update specified named vectors on points, keep unspecified vectors intact.
         * @summary Update vectors
         * @param {string} collectionName Name of the collection to update from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {UpdateVectors} [updateVectors] Update named vectors on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVectors: async (collectionName: string, wait?: boolean, ordering?: WriteOrdering, updateVectors?: UpdateVectors, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('updateVectors', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points/vectors`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVectors, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
         * @summary Upsert points
         * @param {string} collectionName Name of the collection to update from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {PointInsertOperations} [pointInsertOperations] Operation to perform on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertPoints: async (collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointInsertOperations?: PointInsertOperations, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('upsertPoints', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/points`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pointInsertOperations, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PointsApi - functional programming interface
 * @export
 */
export const PointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PointsApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove all payload for specified points
         * @summary Clear payload
         * @param {string} collectionName Name of the collection to clear payload from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {PointsSelector} [pointsSelector] clear payload on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearPayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointsSelector?: PointsSelector, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearPayload(collectionName, wait, ordering, pointsSelector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Count points which matches given filtering condition
         * @summary Count points
         * @param {string} collectionName Name of the collection to count in
         * @param {CountRequest} [countRequest] Request counts of points which matches given filtering condition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countPoints(collectionName: string, countRequest?: CountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountPoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countPoints(collectionName, countRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete specified key payload for points
         * @summary Delete payload
         * @param {string} collectionName Name of the collection to delete from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {DeletePayload} [deletePayload] delete payload on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, deletePayload?: DeletePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePayload(collectionName, wait, ordering, deletePayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete points
         * @summary Delete points
         * @param {string} collectionName Name of the collection to delete from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {PointsSelector} [pointsSelector] Operation to perform on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePoints(collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointsSelector?: PointsSelector, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePoints(collectionName, wait, ordering, pointsSelector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete named vectors from the given points.
         * @summary Delete vectors
         * @param {string} collectionName Name of the collection to delete from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {DeleteVectors} [deleteVectors] Delete named vectors from points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVectors(collectionName: string, wait?: boolean, ordering?: WriteOrdering, deleteVectors?: DeleteVectors, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVectors(collectionName, wait, ordering, deleteVectors, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve full information of single point by id
         * @summary Get point
         * @param {string} collectionName Name of the collection to retrieve from
         * @param {ExtendedPointId} id Id of the point
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoint(collectionName: string, id: ExtendedPointId, consistency?: ReadConsistency, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPoint200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoint(collectionName, id, consistency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve multiple points by specified IDs
         * @summary Get points
         * @param {string} collectionName Name of the collection to retrieve from
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {PointRequest} [pointRequest] List of points to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoints(collectionName: string, consistency?: ReadConsistency, pointRequest?: PointRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoints(collectionName, consistency, pointRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace full payload of points with new one
         * @summary Overwrite payload
         * @param {string} collectionName Name of the collection to set from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {SetPayload} [setPayload] Payload and points selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async overwritePayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, setPayload?: SetPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.overwritePayload(collectionName, wait, ordering, setPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         * @summary Recommend batch points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {RecommendRequestBatch} [recommendRequestBatch] Request points based on positive and negative examples.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recommendBatchPoints(collectionName: string, consistency?: ReadConsistency, recommendRequestBatch?: RecommendRequestBatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchBatchPoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recommendBatchPoints(collectionName, consistency, recommendRequestBatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given payload field.
         * @summary Recommend point groups
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {RecommendGroupsRequest} [recommendGroupsRequest] Request points based on positive and negative examples, grouped by a payload field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recommendPointGroups(collectionName: string, consistency?: ReadConsistency, recommendGroupsRequest?: RecommendGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchPointGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recommendPointGroups(collectionName, consistency, recommendGroupsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         * @summary Recommend points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {RecommendRequest} [recommendRequest] Request points based on positive and negative examples.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recommendPoints(collectionName: string, consistency?: ReadConsistency, recommendRequest?: RecommendRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchPoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recommendPoints(collectionName, consistency, recommendRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Scroll request - paginate over all points which matches given filtering condition
         * @summary Scroll points
         * @param {string} collectionName Name of the collection to retrieve from
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {ScrollRequest} [scrollRequest] Pagination and filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scrollPoints(collectionName: string, consistency?: ReadConsistency, scrollRequest?: ScrollRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScrollPoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scrollPoints(collectionName, consistency, scrollRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve by batch the closest points based on vector similarity and given filtering conditions
         * @summary Search batch points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {SearchRequestBatch} [searchRequestBatch] Search batch request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBatchPoints(collectionName: string, consistency?: ReadConsistency, searchRequestBatch?: SearchRequestBatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchBatchPoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBatchPoints(collectionName, consistency, searchRequestBatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given payload field
         * @summary Search point groups
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {SearchGroupsRequest} [searchGroupsRequest] Search request with optional filtering, grouped by a given payload field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPointGroups(collectionName: string, consistency?: ReadConsistency, searchGroupsRequest?: SearchGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchPointGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPointGroups(collectionName, consistency, searchGroupsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve closest points based on vector similarity and given filtering conditions
         * @summary Search points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {SearchRequest} [searchRequest] Search request with optional filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPoints(collectionName: string, consistency?: ReadConsistency, searchRequest?: SearchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchPoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPoints(collectionName, consistency, searchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set payload values for points
         * @summary Set payload
         * @param {string} collectionName Name of the collection to set from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {SetPayload} [setPayload] Set payload on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, setPayload?: SetPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPayload(collectionName, wait, ordering, setPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update specified named vectors on points, keep unspecified vectors intact.
         * @summary Update vectors
         * @param {string} collectionName Name of the collection to update from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {UpdateVectors} [updateVectors] Update named vectors on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVectors(collectionName: string, wait?: boolean, ordering?: WriteOrdering, updateVectors?: UpdateVectors, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVectors(collectionName, wait, ordering, updateVectors, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
         * @summary Upsert points
         * @param {string} collectionName Name of the collection to update from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {PointInsertOperations} [pointInsertOperations] Operation to perform on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertPoints(collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointInsertOperations?: PointInsertOperations, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFieldIndex200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertPoints(collectionName, wait, ordering, pointInsertOperations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PointsApi - factory interface
 * @export
 */
export const PointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PointsApiFp(configuration)
    return {
        /**
         * Remove all payload for specified points
         * @summary Clear payload
         * @param {string} collectionName Name of the collection to clear payload from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {PointsSelector} [pointsSelector] clear payload on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearPayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointsSelector?: PointsSelector, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.clearPayload(collectionName, wait, ordering, pointsSelector, options).then((request) => request(axios, basePath));
        },
        /**
         * Count points which matches given filtering condition
         * @summary Count points
         * @param {string} collectionName Name of the collection to count in
         * @param {CountRequest} [countRequest] Request counts of points which matches given filtering condition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countPoints(collectionName: string, countRequest?: CountRequest, options?: any): AxiosPromise<CountPoints200Response> {
            return localVarFp.countPoints(collectionName, countRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specified key payload for points
         * @summary Delete payload
         * @param {string} collectionName Name of the collection to delete from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {DeletePayload} [deletePayload] delete payload on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, deletePayload?: DeletePayload, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.deletePayload(collectionName, wait, ordering, deletePayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete points
         * @summary Delete points
         * @param {string} collectionName Name of the collection to delete from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {PointsSelector} [pointsSelector] Operation to perform on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePoints(collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointsSelector?: PointsSelector, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.deletePoints(collectionName, wait, ordering, pointsSelector, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete named vectors from the given points.
         * @summary Delete vectors
         * @param {string} collectionName Name of the collection to delete from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {DeleteVectors} [deleteVectors] Delete named vectors from points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVectors(collectionName: string, wait?: boolean, ordering?: WriteOrdering, deleteVectors?: DeleteVectors, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.deleteVectors(collectionName, wait, ordering, deleteVectors, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve full information of single point by id
         * @summary Get point
         * @param {string} collectionName Name of the collection to retrieve from
         * @param {ExtendedPointId} id Id of the point
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoint(collectionName: string, id: ExtendedPointId, consistency?: ReadConsistency, options?: any): AxiosPromise<GetPoint200Response> {
            return localVarFp.getPoint(collectionName, id, consistency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve multiple points by specified IDs
         * @summary Get points
         * @param {string} collectionName Name of the collection to retrieve from
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {PointRequest} [pointRequest] List of points to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoints(collectionName: string, consistency?: ReadConsistency, pointRequest?: PointRequest, options?: any): AxiosPromise<GetPoints200Response> {
            return localVarFp.getPoints(collectionName, consistency, pointRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace full payload of points with new one
         * @summary Overwrite payload
         * @param {string} collectionName Name of the collection to set from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {SetPayload} [setPayload] Payload and points selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        overwritePayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, setPayload?: SetPayload, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.overwritePayload(collectionName, wait, ordering, setPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         * @summary Recommend batch points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {RecommendRequestBatch} [recommendRequestBatch] Request points based on positive and negative examples.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendBatchPoints(collectionName: string, consistency?: ReadConsistency, recommendRequestBatch?: RecommendRequestBatch, options?: any): AxiosPromise<SearchBatchPoints200Response> {
            return localVarFp.recommendBatchPoints(collectionName, consistency, recommendRequestBatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given payload field.
         * @summary Recommend point groups
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {RecommendGroupsRequest} [recommendGroupsRequest] Request points based on positive and negative examples, grouped by a payload field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendPointGroups(collectionName: string, consistency?: ReadConsistency, recommendGroupsRequest?: RecommendGroupsRequest, options?: any): AxiosPromise<SearchPointGroups200Response> {
            return localVarFp.recommendPointGroups(collectionName, consistency, recommendGroupsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
         * @summary Recommend points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {RecommendRequest} [recommendRequest] Request points based on positive and negative examples.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recommendPoints(collectionName: string, consistency?: ReadConsistency, recommendRequest?: RecommendRequest, options?: any): AxiosPromise<SearchPoints200Response> {
            return localVarFp.recommendPoints(collectionName, consistency, recommendRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Scroll request - paginate over all points which matches given filtering condition
         * @summary Scroll points
         * @param {string} collectionName Name of the collection to retrieve from
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {ScrollRequest} [scrollRequest] Pagination and filter parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrollPoints(collectionName: string, consistency?: ReadConsistency, scrollRequest?: ScrollRequest, options?: any): AxiosPromise<ScrollPoints200Response> {
            return localVarFp.scrollPoints(collectionName, consistency, scrollRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve by batch the closest points based on vector similarity and given filtering conditions
         * @summary Search batch points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {SearchRequestBatch} [searchRequestBatch] Search batch request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBatchPoints(collectionName: string, consistency?: ReadConsistency, searchRequestBatch?: SearchRequestBatch, options?: any): AxiosPromise<SearchBatchPoints200Response> {
            return localVarFp.searchBatchPoints(collectionName, consistency, searchRequestBatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given payload field
         * @summary Search point groups
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {SearchGroupsRequest} [searchGroupsRequest] Search request with optional filtering, grouped by a given payload field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPointGroups(collectionName: string, consistency?: ReadConsistency, searchGroupsRequest?: SearchGroupsRequest, options?: any): AxiosPromise<SearchPointGroups200Response> {
            return localVarFp.searchPointGroups(collectionName, consistency, searchGroupsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve closest points based on vector similarity and given filtering conditions
         * @summary Search points
         * @param {string} collectionName Name of the collection to search in
         * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
         * @param {SearchRequest} [searchRequest] Search request with optional filtering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPoints(collectionName: string, consistency?: ReadConsistency, searchRequest?: SearchRequest, options?: any): AxiosPromise<SearchPoints200Response> {
            return localVarFp.searchPoints(collectionName, consistency, searchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set payload values for points
         * @summary Set payload
         * @param {string} collectionName Name of the collection to set from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {SetPayload} [setPayload] Set payload on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, setPayload?: SetPayload, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.setPayload(collectionName, wait, ordering, setPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Update specified named vectors on points, keep unspecified vectors intact.
         * @summary Update vectors
         * @param {string} collectionName Name of the collection to update from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {UpdateVectors} [updateVectors] Update named vectors on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVectors(collectionName: string, wait?: boolean, ordering?: WriteOrdering, updateVectors?: UpdateVectors, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.updateVectors(collectionName, wait, ordering, updateVectors, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
         * @summary Upsert points
         * @param {string} collectionName Name of the collection to update from
         * @param {boolean} [wait] If true, wait for changes to actually happen
         * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
         * @param {PointInsertOperations} [pointInsertOperations] Operation to perform on points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertPoints(collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointInsertOperations?: PointInsertOperations, options?: any): AxiosPromise<CreateFieldIndex200Response> {
            return localVarFp.upsertPoints(collectionName, wait, ordering, pointInsertOperations, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PointsApi - object-oriented interface
 * @export
 * @class PointsApi
 * @extends {BaseAPI}
 */
export class PointsApi extends BaseAPI {
    /**
     * Remove all payload for specified points
     * @summary Clear payload
     * @param {string} collectionName Name of the collection to clear payload from
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {PointsSelector} [pointsSelector] clear payload on points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public clearPayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointsSelector?: PointsSelector, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).clearPayload(collectionName, wait, ordering, pointsSelector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Count points which matches given filtering condition
     * @summary Count points
     * @param {string} collectionName Name of the collection to count in
     * @param {CountRequest} [countRequest] Request counts of points which matches given filtering condition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public countPoints(collectionName: string, countRequest?: CountRequest, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).countPoints(collectionName, countRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete specified key payload for points
     * @summary Delete payload
     * @param {string} collectionName Name of the collection to delete from
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {DeletePayload} [deletePayload] delete payload on points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public deletePayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, deletePayload?: DeletePayload, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).deletePayload(collectionName, wait, ordering, deletePayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete points
     * @summary Delete points
     * @param {string} collectionName Name of the collection to delete from
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {PointsSelector} [pointsSelector] Operation to perform on points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public deletePoints(collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointsSelector?: PointsSelector, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).deletePoints(collectionName, wait, ordering, pointsSelector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete named vectors from the given points.
     * @summary Delete vectors
     * @param {string} collectionName Name of the collection to delete from
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {DeleteVectors} [deleteVectors] Delete named vectors from points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public deleteVectors(collectionName: string, wait?: boolean, ordering?: WriteOrdering, deleteVectors?: DeleteVectors, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).deleteVectors(collectionName, wait, ordering, deleteVectors, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve full information of single point by id
     * @summary Get point
     * @param {string} collectionName Name of the collection to retrieve from
     * @param {ExtendedPointId} id Id of the point
     * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public getPoint(collectionName: string, id: ExtendedPointId, consistency?: ReadConsistency, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).getPoint(collectionName, id, consistency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve multiple points by specified IDs
     * @summary Get points
     * @param {string} collectionName Name of the collection to retrieve from
     * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
     * @param {PointRequest} [pointRequest] List of points to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public getPoints(collectionName: string, consistency?: ReadConsistency, pointRequest?: PointRequest, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).getPoints(collectionName, consistency, pointRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace full payload of points with new one
     * @summary Overwrite payload
     * @param {string} collectionName Name of the collection to set from
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {SetPayload} [setPayload] Payload and points selector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public overwritePayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, setPayload?: SetPayload, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).overwritePayload(collectionName, wait, ordering, setPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
     * @summary Recommend batch points
     * @param {string} collectionName Name of the collection to search in
     * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
     * @param {RecommendRequestBatch} [recommendRequestBatch] Request points based on positive and negative examples.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public recommendBatchPoints(collectionName: string, consistency?: ReadConsistency, recommendRequestBatch?: RecommendRequestBatch, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).recommendBatchPoints(collectionName, consistency, recommendRequestBatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given payload field.
     * @summary Recommend point groups
     * @param {string} collectionName Name of the collection to search in
     * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
     * @param {RecommendGroupsRequest} [recommendGroupsRequest] Request points based on positive and negative examples, grouped by a payload field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public recommendPointGroups(collectionName: string, consistency?: ReadConsistency, recommendGroupsRequest?: RecommendGroupsRequest, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).recommendPointGroups(collectionName, consistency, recommendGroupsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
     * @summary Recommend points
     * @param {string} collectionName Name of the collection to search in
     * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
     * @param {RecommendRequest} [recommendRequest] Request points based on positive and negative examples.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public recommendPoints(collectionName: string, consistency?: ReadConsistency, recommendRequest?: RecommendRequest, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).recommendPoints(collectionName, consistency, recommendRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Scroll request - paginate over all points which matches given filtering condition
     * @summary Scroll points
     * @param {string} collectionName Name of the collection to retrieve from
     * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
     * @param {ScrollRequest} [scrollRequest] Pagination and filter parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public scrollPoints(collectionName: string, consistency?: ReadConsistency, scrollRequest?: ScrollRequest, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).scrollPoints(collectionName, consistency, scrollRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve by batch the closest points based on vector similarity and given filtering conditions
     * @summary Search batch points
     * @param {string} collectionName Name of the collection to search in
     * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
     * @param {SearchRequestBatch} [searchRequestBatch] Search batch request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public searchBatchPoints(collectionName: string, consistency?: ReadConsistency, searchRequestBatch?: SearchRequestBatch, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).searchBatchPoints(collectionName, consistency, searchRequestBatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given payload field
     * @summary Search point groups
     * @param {string} collectionName Name of the collection to search in
     * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
     * @param {SearchGroupsRequest} [searchGroupsRequest] Search request with optional filtering, grouped by a given payload field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public searchPointGroups(collectionName: string, consistency?: ReadConsistency, searchGroupsRequest?: SearchGroupsRequest, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).searchPointGroups(collectionName, consistency, searchGroupsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve closest points based on vector similarity and given filtering conditions
     * @summary Search points
     * @param {string} collectionName Name of the collection to search in
     * @param {ReadConsistency} [consistency] Define read consistency guarantees for the operation
     * @param {SearchRequest} [searchRequest] Search request with optional filtering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public searchPoints(collectionName: string, consistency?: ReadConsistency, searchRequest?: SearchRequest, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).searchPoints(collectionName, consistency, searchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set payload values for points
     * @summary Set payload
     * @param {string} collectionName Name of the collection to set from
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {SetPayload} [setPayload] Set payload on points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public setPayload(collectionName: string, wait?: boolean, ordering?: WriteOrdering, setPayload?: SetPayload, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).setPayload(collectionName, wait, ordering, setPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update specified named vectors on points, keep unspecified vectors intact.
     * @summary Update vectors
     * @param {string} collectionName Name of the collection to update from
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {UpdateVectors} [updateVectors] Update named vectors on points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public updateVectors(collectionName: string, wait?: boolean, ordering?: WriteOrdering, updateVectors?: UpdateVectors, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).updateVectors(collectionName, wait, ordering, updateVectors, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
     * @summary Upsert points
     * @param {string} collectionName Name of the collection to update from
     * @param {boolean} [wait] If true, wait for changes to actually happen
     * @param {WriteOrdering} [ordering] define ordering guarantees for the operation
     * @param {PointInsertOperations} [pointInsertOperations] Operation to perform on points
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public upsertPoints(collectionName: string, wait?: boolean, ordering?: WriteOrdering, pointInsertOperations?: PointInsertOperations, options?: AxiosRequestConfig) {
        return PointsApiFp(this.configuration).upsertPoints(collectionName, wait, ordering, pointInsertOperations, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceApi - axios parameter creator
 * @export
 */
export const ServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get lock options. If write is locked, all write operations and collection creation are forbidden
         * @summary Get lock options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect metrics data including app info, collections info, cluster info and statistics
         * @summary Collect Prometheus metrics data
         * @param {boolean} [anonymize] If true, anonymize result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics: async (anonymize?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (anonymize !== undefined) {
                localVarQueryParameter['anonymize'] = anonymize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set lock options. If write is locked, all write operations and collection creation are forbidden. Returns previous lock options
         * @summary Set lock options
         * @param {LocksOption} [locksOption] Lock options and optional error message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLocks: async (locksOption?: LocksOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locksOption, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect telemetry data including app info, system info, collections info, cluster info, configs and statistics
         * @summary Collect telemetry data
         * @param {boolean} [anonymize] If true, anonymize result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetry: async (anonymize?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/telemetry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (anonymize !== undefined) {
                localVarQueryParameter['anonymize'] = anonymize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get lock options. If write is locked, all write operations and collection creation are forbidden
         * @summary Get lock options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLocks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Collect metrics data including app info, collections info, cluster info and statistics
         * @summary Collect Prometheus metrics data
         * @param {boolean} [anonymize] If true, anonymize result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metrics(anonymize?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(anonymize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set lock options. If write is locked, all write operations and collection creation are forbidden. Returns previous lock options
         * @summary Set lock options
         * @param {LocksOption} [locksOption] Lock options and optional error message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLocks(locksOption?: LocksOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLocks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLocks(locksOption, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Collect telemetry data including app info, system info, collections info, cluster info, configs and statistics
         * @summary Collect telemetry data
         * @param {boolean} [anonymize] If true, anonymize result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telemetry(anonymize?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Telemetry200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telemetry(anonymize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceApiFp(configuration)
    return {
        /**
         * Get lock options. If write is locked, all write operations and collection creation are forbidden
         * @summary Get lock options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocks(options?: any): AxiosPromise<GetLocks200Response> {
            return localVarFp.getLocks(options).then((request) => request(axios, basePath));
        },
        /**
         * Collect metrics data including app info, collections info, cluster info and statistics
         * @summary Collect Prometheus metrics data
         * @param {boolean} [anonymize] If true, anonymize result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(anonymize?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.metrics(anonymize, options).then((request) => request(axios, basePath));
        },
        /**
         * Set lock options. If write is locked, all write operations and collection creation are forbidden. Returns previous lock options
         * @summary Set lock options
         * @param {LocksOption} [locksOption] Lock options and optional error message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLocks(locksOption?: LocksOption, options?: any): AxiosPromise<GetLocks200Response> {
            return localVarFp.postLocks(locksOption, options).then((request) => request(axios, basePath));
        },
        /**
         * Collect telemetry data including app info, system info, collections info, cluster info, configs and statistics
         * @summary Collect telemetry data
         * @param {boolean} [anonymize] If true, anonymize result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetry(anonymize?: boolean, options?: any): AxiosPromise<Telemetry200Response> {
            return localVarFp.telemetry(anonymize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
    /**
     * Get lock options. If write is locked, all write operations and collection creation are forbidden
     * @summary Get lock options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getLocks(options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getLocks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Collect metrics data including app info, collections info, cluster info and statistics
     * @summary Collect Prometheus metrics data
     * @param {boolean} [anonymize] If true, anonymize result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public metrics(anonymize?: boolean, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).metrics(anonymize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set lock options. If write is locked, all write operations and collection creation are forbidden. Returns previous lock options
     * @summary Set lock options
     * @param {LocksOption} [locksOption] Lock options and optional error message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public postLocks(locksOption?: LocksOption, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).postLocks(locksOption, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Collect telemetry data including app info, system info, collections info, cluster info, configs and statistics
     * @summary Collect telemetry data
     * @param {boolean} [anonymize] If true, anonymize result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public telemetry(anonymize?: boolean, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).telemetry(anonymize, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SnapshotsApi - axios parameter creator
 * @export
 */
export const SnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new snapshot of the whole storage
         * @summary Create storage snapshot
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullSnapshot: async (wait?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new snapshot for a collection
         * @summary Create collection snapshot
         * @param {string} collectionName Name of the collection for which to create a snapshot
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot: async (collectionName: string, wait?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('createSnapshot', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/snapshots`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete snapshot of the whole storage
         * @summary Delete storage snapshot
         * @param {string} snapshotName Name of the full snapshot to delete
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFullSnapshot: async (snapshotName: string, wait?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotName' is not null or undefined
            assertParamExists('deleteFullSnapshot', 'snapshotName', snapshotName)
            const localVarPath = `/snapshots/{snapshot_name}`
                .replace(`{${"snapshot_name"}}`, encodeURIComponent(String(snapshotName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete snapshot for a collection
         * @summary Delete collection snapshot
         * @param {string} collectionName Name of the collection for which to delete a snapshot
         * @param {string} snapshotName Name of the snapshot to delete
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot: async (collectionName: string, snapshotName: string, wait?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('deleteSnapshot', 'collectionName', collectionName)
            // verify required parameter 'snapshotName' is not null or undefined
            assertParamExists('deleteSnapshot', 'snapshotName', snapshotName)
            const localVarPath = `/collections/{collection_name}/snapshots/{snapshot_name}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)))
                .replace(`{${"snapshot_name"}}`, encodeURIComponent(String(snapshotName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download specified snapshot of the whole storage as a file
         * @summary Download storage snapshot
         * @param {string} snapshotName Name of the snapshot to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullSnapshot: async (snapshotName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapshotName' is not null or undefined
            assertParamExists('getFullSnapshot', 'snapshotName', snapshotName)
            const localVarPath = `/snapshots/{snapshot_name}`
                .replace(`{${"snapshot_name"}}`, encodeURIComponent(String(snapshotName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download specified snapshot from a collection as a file
         * @summary Download collection snapshot
         * @param {string} collectionName Name of the collection
         * @param {string} snapshotName Name of the snapshot to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot: async (collectionName: string, snapshotName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('getSnapshot', 'collectionName', collectionName)
            // verify required parameter 'snapshotName' is not null or undefined
            assertParamExists('getSnapshot', 'snapshotName', snapshotName)
            const localVarPath = `/collections/{collection_name}/snapshots/{snapshot_name}`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)))
                .replace(`{${"snapshot_name"}}`, encodeURIComponent(String(snapshotName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of snapshots of the whole storage
         * @summary List of storage snapshots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFullSnapshots: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of snapshots for a collection
         * @summary List collection snapshots
         * @param {string} collectionName Name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshots: async (collectionName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('listSnapshots', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/snapshots`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from a snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotRecover} [snapshotRecover] Snapshot to recover from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverFromSnapshot: async (collectionName: string, wait?: boolean, snapshotRecover?: SnapshotRecover, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('recoverFromSnapshot', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/snapshots/recover`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(snapshotRecover, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from an uploaded snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotPriority} [priority] Defines source of truth for snapshot recovery
         * @param {File} [snapshot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverFromUploadedSnapshot: async (collectionName: string, wait?: boolean, priority?: SnapshotPriority, snapshot?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionName' is not null or undefined
            assertParamExists('recoverFromUploadedSnapshot', 'collectionName', collectionName)
            const localVarPath = `/collections/{collection_name}/snapshots/upload`
                .replace(`{${"collection_name"}}`, encodeURIComponent(String(collectionName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (wait !== undefined) {
                localVarQueryParameter['wait'] = wait;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }


            if (snapshot !== undefined) { 
                localVarFormParams.append('snapshot', snapshot as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnapshotsApi - functional programming interface
 * @export
 */
export const SnapshotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SnapshotsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new snapshot of the whole storage
         * @summary Create storage snapshot
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFullSnapshot(wait?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFullSnapshot(wait, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new snapshot for a collection
         * @summary Create collection snapshot
         * @param {string} collectionName Name of the collection for which to create a snapshot
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSnapshot(collectionName: string, wait?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSnapshot(collectionName, wait, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete snapshot of the whole storage
         * @summary Delete storage snapshot
         * @param {string} snapshotName Name of the full snapshot to delete
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFullSnapshot(snapshotName: string, wait?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFullSnapshot(snapshotName, wait, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete snapshot for a collection
         * @summary Delete collection snapshot
         * @param {string} collectionName Name of the collection for which to delete a snapshot
         * @param {string} snapshotName Name of the snapshot to delete
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSnapshot(collectionName: string, snapshotName: string, wait?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSnapshot(collectionName, snapshotName, wait, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download specified snapshot of the whole storage as a file
         * @summary Download storage snapshot
         * @param {string} snapshotName Name of the snapshot to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFullSnapshot(snapshotName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFullSnapshot(snapshotName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download specified snapshot from a collection as a file
         * @summary Download collection snapshot
         * @param {string} collectionName Name of the collection
         * @param {string} snapshotName Name of the snapshot to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshot(collectionName: string, snapshotName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshot(collectionName, snapshotName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of snapshots of the whole storage
         * @summary List of storage snapshots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFullSnapshots(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSnapshots200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFullSnapshots(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list of snapshots for a collection
         * @summary List collection snapshots
         * @param {string} collectionName Name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSnapshots(collectionName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSnapshots200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSnapshots(collectionName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from a snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotRecover} [snapshotRecover] Snapshot to recover from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverFromSnapshot(collectionName: string, wait?: boolean, snapshotRecover?: SnapshotRecover, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverFromSnapshot(collectionName, wait, snapshotRecover, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from an uploaded snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotPriority} [priority] Defines source of truth for snapshot recovery
         * @param {File} [snapshot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverFromUploadedSnapshot(collectionName: string, wait?: boolean, priority?: SnapshotPriority, snapshot?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecoverCurrentPeer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverFromUploadedSnapshot(collectionName, wait, priority, snapshot, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SnapshotsApi - factory interface
 * @export
 */
export const SnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SnapshotsApiFp(configuration)
    return {
        /**
         * Create new snapshot of the whole storage
         * @summary Create storage snapshot
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullSnapshot(wait?: boolean, options?: any): AxiosPromise<CreateSnapshot200Response> {
            return localVarFp.createFullSnapshot(wait, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new snapshot for a collection
         * @summary Create collection snapshot
         * @param {string} collectionName Name of the collection for which to create a snapshot
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot(collectionName: string, wait?: boolean, options?: any): AxiosPromise<CreateSnapshot200Response> {
            return localVarFp.createSnapshot(collectionName, wait, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete snapshot of the whole storage
         * @summary Delete storage snapshot
         * @param {string} snapshotName Name of the full snapshot to delete
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFullSnapshot(snapshotName: string, wait?: boolean, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.deleteFullSnapshot(snapshotName, wait, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete snapshot for a collection
         * @summary Delete collection snapshot
         * @param {string} collectionName Name of the collection for which to delete a snapshot
         * @param {string} snapshotName Name of the snapshot to delete
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapshot(collectionName: string, snapshotName: string, wait?: boolean, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.deleteSnapshot(collectionName, snapshotName, wait, options).then((request) => request(axios, basePath));
        },
        /**
         * Download specified snapshot of the whole storage as a file
         * @summary Download storage snapshot
         * @param {string} snapshotName Name of the snapshot to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFullSnapshot(snapshotName: string, options?: any): AxiosPromise<File> {
            return localVarFp.getFullSnapshot(snapshotName, options).then((request) => request(axios, basePath));
        },
        /**
         * Download specified snapshot from a collection as a file
         * @summary Download collection snapshot
         * @param {string} collectionName Name of the collection
         * @param {string} snapshotName Name of the snapshot to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot(collectionName: string, snapshotName: string, options?: any): AxiosPromise<File> {
            return localVarFp.getSnapshot(collectionName, snapshotName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of snapshots of the whole storage
         * @summary List of storage snapshots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFullSnapshots(options?: any): AxiosPromise<ListSnapshots200Response> {
            return localVarFp.listFullSnapshots(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of snapshots for a collection
         * @summary List collection snapshots
         * @param {string} collectionName Name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapshots(collectionName: string, options?: any): AxiosPromise<ListSnapshots200Response> {
            return localVarFp.listSnapshots(collectionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from a snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotRecover} [snapshotRecover] Snapshot to recover from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverFromSnapshot(collectionName: string, wait?: boolean, snapshotRecover?: SnapshotRecover, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.recoverFromSnapshot(collectionName, wait, snapshotRecover, options).then((request) => request(axios, basePath));
        },
        /**
         * Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
         * @summary Recover from an uploaded snapshot
         * @param {string} collectionName Name of the collection
         * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
         * @param {SnapshotPriority} [priority] Defines source of truth for snapshot recovery
         * @param {File} [snapshot] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverFromUploadedSnapshot(collectionName: string, wait?: boolean, priority?: SnapshotPriority, snapshot?: File, options?: any): AxiosPromise<RecoverCurrentPeer200Response> {
            return localVarFp.recoverFromUploadedSnapshot(collectionName, wait, priority, snapshot, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SnapshotsApi - object-oriented interface
 * @export
 * @class SnapshotsApi
 * @extends {BaseAPI}
 */
export class SnapshotsApi extends BaseAPI {
    /**
     * Create new snapshot of the whole storage
     * @summary Create storage snapshot
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public createFullSnapshot(wait?: boolean, options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).createFullSnapshot(wait, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new snapshot for a collection
     * @summary Create collection snapshot
     * @param {string} collectionName Name of the collection for which to create a snapshot
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public createSnapshot(collectionName: string, wait?: boolean, options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).createSnapshot(collectionName, wait, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete snapshot of the whole storage
     * @summary Delete storage snapshot
     * @param {string} snapshotName Name of the full snapshot to delete
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public deleteFullSnapshot(snapshotName: string, wait?: boolean, options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).deleteFullSnapshot(snapshotName, wait, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete snapshot for a collection
     * @summary Delete collection snapshot
     * @param {string} collectionName Name of the collection for which to delete a snapshot
     * @param {string} snapshotName Name of the snapshot to delete
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public deleteSnapshot(collectionName: string, snapshotName: string, wait?: boolean, options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).deleteSnapshot(collectionName, snapshotName, wait, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download specified snapshot of the whole storage as a file
     * @summary Download storage snapshot
     * @param {string} snapshotName Name of the snapshot to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public getFullSnapshot(snapshotName: string, options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).getFullSnapshot(snapshotName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download specified snapshot from a collection as a file
     * @summary Download collection snapshot
     * @param {string} collectionName Name of the collection
     * @param {string} snapshotName Name of the snapshot to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public getSnapshot(collectionName: string, snapshotName: string, options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).getSnapshot(collectionName, snapshotName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of snapshots of the whole storage
     * @summary List of storage snapshots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public listFullSnapshots(options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).listFullSnapshots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of snapshots for a collection
     * @summary List collection snapshots
     * @param {string} collectionName Name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public listSnapshots(collectionName: string, options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).listSnapshots(collectionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
     * @summary Recover from a snapshot
     * @param {string} collectionName Name of the collection
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {SnapshotRecover} [snapshotRecover] Snapshot to recover from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public recoverFromSnapshot(collectionName: string, wait?: boolean, snapshotRecover?: SnapshotRecover, options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).recoverFromSnapshot(collectionName, wait, snapshotRecover, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
     * @summary Recover from an uploaded snapshot
     * @param {string} collectionName Name of the collection
     * @param {boolean} [wait] If true, wait for changes to actually happen. If false - let changes happen in background. Default is true.
     * @param {SnapshotPriority} [priority] Defines source of truth for snapshot recovery
     * @param {File} [snapshot] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public recoverFromUploadedSnapshot(collectionName: string, wait?: boolean, priority?: SnapshotPriority, snapshot?: File, options?: AxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).recoverFromUploadedSnapshot(collectionName, wait, priority, snapshot, options).then((request) => request(this.axios, this.basePath));
    }
}


